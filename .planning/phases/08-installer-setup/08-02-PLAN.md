---
phase: 08-installer-setup
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - homebrew/Casks/terminal-remote.rb
  - .github/workflows/release.yml
autonomous: true

must_haves:
  truths:
    - "Homebrew cask definition installs Terminal Remote with brew install --cask"
    - "GitHub Actions workflow builds both binaries for arm64 and x86_64 on tag push"
    - "Release artifacts are packaged as tar.gz archives matching install.sh URL pattern"
  artifacts:
    - path: "homebrew/Casks/terminal-remote.rb"
      provides: "Homebrew cask for Terminal Remote"
      min_lines: 40
    - path: ".github/workflows/release.yml"
      provides: "Automated release pipeline"
      min_lines: 60
  key_links:
    - from: "homebrew/Casks/terminal-remote.rb"
      to: "GitHub Releases"
      via: "url download spec per architecture"
      pattern: "github.com.*releases/download"
    - from: ".github/workflows/release.yml"
      to: "cargo build"
      via: "cross-compilation for arm64 and x86_64"
      pattern: "cargo build --release"
    - from: ".github/workflows/release.yml"
      to: "scripts/install.sh"
      via: "release asset naming convention matches download URL"
      pattern: "terminal-remote.*darwin.*tar.gz"
---

<objective>
Create the Homebrew cask for tap-based installation and the GitHub Actions release workflow that builds and publishes pre-built binaries for both Mac architectures.

Purpose: Provide an alternative `brew install --cask terminal-remote` path for users who prefer Homebrew, and automate the binary release pipeline so the curl|sh installer has artifacts to download.

Output: A Homebrew cask definition and a GitHub Actions workflow for automated releases.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-installer-setup/08-CONTEXT.md

# Build and packaging references
@mac-client/Cargo.toml
@mac-client/build-bundle.sh
@mac-client/Info.plist
@relay-server/Cargo.toml
@scripts/setup.sh
@shell-integration/install.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Homebrew cask definition</name>
  <files>homebrew/Casks/terminal-remote.rb</files>
  <action>
Create `homebrew/Casks/terminal-remote.rb` -- a Homebrew cask that installs Terminal Remote.

**Why a Cask (not Formula):** The mac-client is a .app bundle (GUI application). Homebrew Casks are the correct mechanism for .app bundles. Formulae are for CLI tools only.

**Cask structure:**

```ruby
cask "terminal-remote" do
  version "2.0.0"
  sha256 arm:   "PLACEHOLDER_ARM64_SHA256",
         intel: "PLACEHOLDER_X86_64_SHA256"

  on_arm do
    url "https://github.com/studium-ignotum/iterm2-remote/releases/download/v#{version}/terminal-remote-v#{version}-darwin-arm64.tar.gz"
  end
  on_intel do
    url "https://github.com/studium-ignotum/iterm2-remote/releases/download/v#{version}/terminal-remote-v#{version}-darwin-x86_64.tar.gz"
  end

  name "Terminal Remote"
  desc "Control any terminal session from anywhere via browser"
  homepage "https://github.com/studium-ignotum/iterm2-remote"

  # Install the .app bundle
  app "Terminal Remote.app"

  # Install relay-server binary and shell integration
  binary "relay-server", target: "#{HOMEBREW_PREFIX}/bin/terminal-remote-relay"

  # Post-install: copy shell integration scripts
  postflight do
    install_dir = "#{Dir.home}/.terminal-remote"
    FileUtils.mkdir_p(install_dir)

    # Copy init scripts from the extracted archive
    ["init.zsh", "init.bash", "init.fish"].each do |script|
      source = "#{staged_path}/shell-integration/#{script}"
      FileUtils.cp(source, install_dir) if File.exist?(source)
    end
  end

  # Create launcher script
  postflight do
    install_dir = "#{Dir.home}/.terminal-remote"
    bin_dir = "#{install_dir}/bin"
    FileUtils.mkdir_p(bin_dir)

    launcher = "#{bin_dir}/terminal-remote-start"
    File.write(launcher, <<~SCRIPT)
      #!/bin/bash
      if ! pgrep -f "terminal-remote-relay" > /dev/null 2>&1; then
        terminal-remote-relay &
        sleep 0.5
      fi
      open "#{Dir.home}/Applications/Terminal Remote.app"
    SCRIPT
    FileUtils.chmod(0o755, launcher)
  end

  # Uninstall: clean up shell integration and config
  uninstall_postflight do
    install_dir = "#{Dir.home}/.terminal-remote"
    FileUtils.rm_rf(install_dir) if Dir.exist?(install_dir)
  end

  depends_on formula: "cloudflared"
  depends_on formula: "tmux"
  depends_on macos: ">= :ventura"

  caveats <<~EOS
    Add shell integration to your shell configuration.
    Add this line to the END of your rc file (after oh-my-zsh, starship, etc.):

      Zsh (~/.zshrc):
        source ~/.terminal-remote/init.zsh

      Bash (~/.bashrc):
        source ~/.terminal-remote/init.bash

      Fish (~/.config/fish/config.fish):
        source ~/.terminal-remote/init.fish

    Start Terminal Remote:
      ~/.terminal-remote/bin/terminal-remote-start
  EOS
end
```

**Important details:**
- Use `on_arm` / `on_intel` blocks for architecture-specific URLs (Homebrew cask pattern)
- SHA256 values are placeholders -- they get updated when a release is cut
- `depends_on formula:` handles cloudflared and tmux installation
- `depends_on macos: ">= :ventura"` matches LSMinimumSystemVersion 13.0 in Info.plist
- The `app` stanza installs to ~/Applications/ (Homebrew default for casks from taps)
- The `binary` stanza symlinks relay-server to the Homebrew bin
- `postflight` copies shell integration scripts to ~/.terminal-remote/
- `uninstall_postflight` cleans up ~/.terminal-remote/ on `brew uninstall`
- Caveats tell the user to add the source line manually (Homebrew convention -- casks don't modify rc files)

**Tap usage:** This cask lives in the project repo under `homebrew/Casks/`. To set up the tap, create a repo `studium-ignotum/homebrew-terminal-remote` containing just this `Casks/` directory. Users install with:
```
brew tap studium-ignotum/terminal-remote
brew install --cask terminal-remote
```
  </action>
  <verify>
Read the cask file and verify:
1. Architecture-specific URLs match the release asset naming convention (`terminal-remote-v{version}-darwin-{arch}.tar.gz`)
2. `depends_on` includes cloudflared and tmux
3. `depends_on macos` matches the Info.plist minimum (13.0 = ventura)
4. `app` stanza references correct .app bundle name
5. `postflight` creates ~/.terminal-remote/ and copies init scripts
6. Caveats include shell integration instructions for zsh, bash, and fish
  </verify>
  <done>
homebrew/Casks/terminal-remote.rb exists with correct architecture-specific download URLs, dependency declarations, .app installation, shell integration copying, launcher script creation, and user-facing caveats.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GitHub Actions release workflow</name>
  <files>.github/workflows/release.yml</files>
  <action>
Create `.github/workflows/release.yml` -- automated build and release pipeline triggered on version tags.

**Workflow structure:**

```yaml
name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    strategy:
      matrix:
        include:
          - target: aarch64-apple-darwin
            arch: arm64
            os: macos-14          # ARM64 runner
          - target: x86_64-apple-darwin
            arch: x86_64
            os: macos-13          # Intel runner

    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Build web UI
        working-directory: relay-server/web-ui
        run: |
          npm ci
          npm run build

      - name: Build relay-server
        run: |
          cargo build --release --manifest-path relay-server/Cargo.toml --target ${{ matrix.target }}

      - name: Build mac-client
        run: |
          cargo build --release --manifest-path mac-client/Cargo.toml --target ${{ matrix.target }}

      - name: Create .app bundle
        run: |
          BINARY_PATH="mac-client/target/${{ matrix.target }}/release/mac-client"
          APP_NAME="Terminal Remote.app"
          mkdir -p "$APP_NAME/Contents/MacOS"
          mkdir -p "$APP_NAME/Contents/Resources"
          cp "$BINARY_PATH" "$APP_NAME/Contents/MacOS/"
          cp mac-client/Info.plist "$APP_NAME/Contents/"
          if [ -f mac-client/resources/AppIcon.icns ]; then
            cp mac-client/resources/AppIcon.icns "$APP_NAME/Contents/Resources/"
          fi

      - name: Package release archive
        run: |
          VERSION="${GITHUB_REF_NAME}"
          ARCHIVE="terminal-remote-${VERSION}-darwin-${{ matrix.arch }}.tar.gz"

          # Create archive containing:
          #   Terminal Remote.app/  (the .app bundle)
          #   relay-server          (the relay binary)
          #   shell-integration/    (init scripts)

          cp "relay-server/target/${{ matrix.target }}/release/relay-server" ./relay-server-bin
          mkdir -p shell-integration-dist
          cp shell-integration/init.zsh shell-integration-dist/
          cp shell-integration/init.bash shell-integration-dist/
          cp shell-integration/init.fish shell-integration-dist/

          tar -czf "$ARCHIVE" \
            "Terminal Remote.app" \
            -s '/relay-server-bin/relay-server/' relay-server-bin \
            -s '/shell-integration-dist/shell-integration/' shell-integration-dist

          echo "ARCHIVE=$ARCHIVE" >> $GITHUB_ENV

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.arch }}
          path: ${{ env.ARCHIVE }}

  release:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          files: |
            artifacts/release-arm64/*.tar.gz
            artifacts/release-x86_64/*.tar.gz
```

**Key design decisions:**

1. **Matrix build:** Uses `macos-14` (ARM64 M1 runner) and `macos-13` (Intel runner) for native compilation on each architecture. No cross-compilation needed -- each target runs on its native architecture.

2. **Web UI build:** The web UI must be built BEFORE relay-server because rust-embed embeds the built assets at compile time. The workflow runs `npm ci && npm run build` in relay-server/web-ui/ first.

3. **Archive naming:** `terminal-remote-v{version}-darwin-{arch}.tar.gz` matches the URL pattern in both install.sh and the Homebrew cask.

4. **Archive contents:**
   - `Terminal Remote.app/` -- the complete .app bundle with Info.plist and binary
   - `relay-server` -- the relay server binary
   - `shell-integration/` -- init.zsh, init.bash, init.fish

5. **Release creation:** Uses `softprops/action-gh-release@v2` with `generate_release_notes: true` to auto-generate changelog from commits. Both architecture archives are attached as release assets.

6. **Permissions:** `contents: write` is required for creating releases and uploading assets.

**Note on tar command:** The macOS `tar` command supports `-s` for path substitution. The workflow renames `relay-server-bin` to `relay-server` and `shell-integration-dist` to `shell-integration` in the archive. If the macOS tar `-s` flag causes issues, use a staging directory instead:
```bash
mkdir -p staging/shell-integration
cp "Terminal Remote.app" staging/ -R  # (won't work, need different approach)
```
Actually, use a staging directory approach instead of `-s` for reliability:
```bash
STAGING="terminal-remote-staging"
mkdir -p "$STAGING/shell-integration"
cp -R "Terminal Remote.app" "$STAGING/"
cp relay-server-bin "$STAGING/relay-server"
cp shell-integration-dist/* "$STAGING/shell-integration/"
cd "$STAGING" && tar -czf "../$ARCHIVE" . && cd ..
```
Use this staging directory approach in the actual workflow for cross-platform reliability.
  </action>
  <verify>
Read the workflow file and verify:
1. Triggers on `v*` tag push only
2. Matrix includes both `aarch64-apple-darwin` (macos-14) and `x86_64-apple-darwin` (macos-13)
3. Web UI is built BEFORE relay-server (rust-embed dependency)
4. Archive naming matches `terminal-remote-v{version}-darwin-{arch}.tar.gz`
5. Archive contains: Terminal Remote.app, relay-server binary, shell-integration/ scripts
6. Release job depends on build job and creates GitHub Release with both archives
7. `permissions: contents: write` is set
  </verify>
  <done>
.github/workflows/release.yml exists with matrix build for arm64/x86_64, web UI build step before relay-server, correct archive packaging with all components, and automated GitHub Release creation with both architecture archives.
  </done>
</task>

</tasks>

<verification>
1. homebrew/Casks/terminal-remote.rb exists and has correct structure (cask block, url per arch, depends_on, app stanza, postflight, caveats)
2. .github/workflows/release.yml exists and has correct structure (tag trigger, matrix build, web UI step, archive packaging, release creation)
3. Archive naming convention is consistent between: install.sh download URL, cask download URL, and workflow archive output
4. Both files reference the correct GitHub repo (studium-ignotum/iterm2-remote)
5. Workflow builds web UI before relay-server (rust-embed requires pre-built assets)
</verification>

<success_criteria>
- Homebrew cask can be used from a tap to install Terminal Remote with all dependencies
- GitHub Actions workflow builds both binaries for both architectures on tag push
- Release archives contain all required components (.app bundle, relay-server, shell integration scripts)
- Asset naming convention is consistent across install.sh, Homebrew cask, and release workflow
</success_criteria>

<output>
After completion, create `.planning/phases/08-installer-setup/08-02-SUMMARY.md`
</output>
