---
phase: 05-mac-client
plan: 04
type: execute
wave: 3
depends_on: ["05-01", "05-02", "05-03"]
files_modified:
  - mac-client/src/main.rs
  - mac-client/src/app.rs
autonomous: true

must_haves:
  truths:
    - "Menu shows real session code from relay server"
    - "Menu shows connection status (Connected/Disconnected)"
    - "Menu shows session count from IPC connections"
    - "Copy Session Code copies actual code to clipboard"
    - "Copy action shows user-visible confirmation"
  artifacts:
    - path: "mac-client/src/main.rs"
      provides: "Integrated app with background tasks"
      min_lines: 150
    - path: "mac-client/src/app.rs"
      provides: "Application state management"
      contains: "AppState"
  key_links:
    - from: "main.rs"
      to: "relay/mod.rs"
      via: "spawn on background thread"
      pattern: "RelayClient::new"
    - from: "main.rs"
      to: "ipc/mod.rs"
      via: "spawn on background thread"
      pattern: "IpcServer::new"
    - from: "main.rs"
      to: "menu updates"
      via: "channel polling in event loop"
      pattern: "set_text"
---

<objective>
Integrate all modules into a fully functional menu bar app.

Purpose: Wire together the tray icon (05-01), relay client (05-02), and IPC server (05-03) into a cohesive application. The background Tokio thread runs relay and IPC, while the main thread handles UI updates via channels.

Output: A working menu bar app that connects to the relay, displays a real session code, shows connection status, tracks IPC sessions, and supports clipboard copy with user-visible confirmation.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-mac-client/05-RESEARCH.md
@.planning/phases/05-mac-client/05-01-SUMMARY.md
@.planning/phases/05-mac-client/05-02-SUMMARY.md
@.planning/phases/05-mac-client/05-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create app state and channel architecture</name>
  <files>mac-client/src/app.rs, mac-client/src/lib.rs</files>
  <action>
Create app.rs with shared types and state management.

**Define unified event type for main thread:**
```rust
pub enum UiEvent {
    // From relay
    RelayConnected,
    RelayDisconnected,
    SessionCode(String),
    BrowserConnected(String),
    BrowserDisconnected(String),
    RelayError(String),

    // From IPC
    ShellConnected { session_id: String, name: String },
    ShellDisconnected { session_id: String },
    ShellCountChanged(usize),
    IpcError(String),
}
```

**Define command type for background tasks:**
```rust
pub enum BackgroundCommand {
    Shutdown,
    // Future: SendToRelay(message), etc.
}
```

**Create AppState to hold menu items for updates:**
```rust
use muda::MenuItem;

pub struct AppState {
    pub session_code: Option<String>,
    pub relay_connected: bool,
    pub shell_count: usize,
    pub browser_count: usize,

    // Menu items that need updating
    pub code_item: MenuItem,
    pub status_item: MenuItem,
    pub count_item: MenuItem,
    pub copy_item: MenuItem,  // For clipboard confirmation feedback
}

impl AppState {
    pub fn update_code_display(&self) {
        let display = match &self.session_code {
            Some(code) => format!("Code: {}", code),
            None => "Code: ------".to_string(),
        };
        self.code_item.set_text(display);
    }

    pub fn update_status_display(&self) {
        let status = if self.relay_connected { "Connected" } else { "Disconnected" };
        self.status_item.set_text(format!("Status: {}", status));
    }

    pub fn update_count_display(&self) {
        self.count_item.set_text(format!("Sessions: {}", self.shell_count));
    }
}
```

Update lib.rs to export app module.
  </action>
  <verify>
Run `cargo check --manifest-path mac-client/Cargo.toml` - compiles.
  </verify>
  <done>
UiEvent, BackgroundCommand, and AppState defined. Channel architecture ready.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate background tasks in main.rs</name>
  <files>mac-client/src/main.rs</files>
  <action>
Rewrite main.rs to integrate all modules with the threading architecture from research.

**Structure:**

1. **Imports and setup:**
   ```rust
   use mac_client::{app::{AppState, UiEvent, BackgroundCommand}, relay::RelayClient, ipc::IpcServer};
   use std::sync::mpsc;
   use std::thread;
   use tokio::runtime::Runtime;
   ```

2. **Create channels:**
   ```rust
   let (ui_tx, ui_rx) = mpsc::channel::<UiEvent>();
   let (bg_tx, bg_rx) = mpsc::channel::<BackgroundCommand>();
   ```

3. **Spawn background thread with Tokio:**
   ```rust
   let ui_tx_relay = ui_tx.clone();
   let ui_tx_ipc = ui_tx.clone();

   let bg_handle = thread::spawn(move || {
       let rt = Runtime::new().unwrap();
       rt.block_on(async {
           // Get relay URL from env or default
           let relay_url = std::env::var("RELAY_URL")
               .unwrap_or_else(|_| "ws://localhost:3000/ws".to_string());

           // Create relay client with adapter to convert RelayEvent -> UiEvent
           let (relay_event_tx, relay_event_rx) = mpsc::channel();
           let mut relay = RelayClient::new(relay_url, relay_event_tx);

           // Create IPC server with adapter
           let (ipc_event_tx, ipc_event_rx) = mpsc::channel();
           let mut ipc = IpcServer::new(ipc_event_tx).await.expect("Failed to create IPC server");

           // Spawn tasks
           let relay_handle = tokio::spawn(async move {
               relay.run().await;
           });

           let ipc_handle = tokio::spawn(async move {
               ipc.run().await;
           });

           // Event forwarding loops (convert module events to UiEvent)
           // ... spawn tasks to forward relay_event_rx and ipc_event_rx to ui_tx

           // Wait for shutdown signal
           loop {
               if let Ok(BackgroundCommand::Shutdown) = bg_rx.try_recv() {
                   break;
               }
               tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
           }
       });
   });
   ```

4. **Create tray icon and menu (same as 05-01 but with stored MenuItem refs):**
   - Store references to session_code_item, status_item, count_item, copy_item in AppState
   - Menu structure same as before

5. **Main event loop with UI updates and clipboard confirmation:**
   ```rust
   // Track when to reset copy button text
   let mut copy_reset_time: Option<std::time::Instant> = None;

   loop {
       // Handle tray events
       if let Ok(event) = TrayIconEvent::receiver().try_recv() {
           // Handle click if needed
       }

       // Handle menu events
       if let Ok(event) = MenuEvent::receiver().try_recv() {
           match event.id.0.as_str() {
               "copy_code" => {
                   if let Some(code) = &app_state.session_code {
                       let mut clipboard = arboard::Clipboard::new().unwrap();
                       clipboard.set_text(code.clone()).unwrap();
                       tracing::info!("Session code copied to clipboard");

                       // Show confirmation by changing menu item text
                       app_state.copy_item.set_text("Copied!");
                       copy_reset_time = Some(std::time::Instant::now() + std::time::Duration::from_secs(2));
                   }
               }
               "quit" => {
                   bg_tx.send(BackgroundCommand::Shutdown).ok();
                   break;
               }
               _ => {}
           }
       }

       // Reset copy button text after 2 seconds
       if let Some(reset_time) = copy_reset_time {
           if std::time::Instant::now() >= reset_time {
               app_state.copy_item.set_text("Copy Session Code");
               copy_reset_time = None;
           }
       }

       // Handle UI events from background
       while let Ok(event) = ui_rx.try_recv() {
           match event {
               UiEvent::RelayConnected => {
                   app_state.relay_connected = true;
                   app_state.update_status_display();
               }
               UiEvent::RelayDisconnected => {
                   app_state.relay_connected = false;
                   app_state.update_status_display();
               }
               UiEvent::SessionCode(code) => {
                   app_state.session_code = Some(code);
                   app_state.update_code_display();
               }
               UiEvent::ShellCountChanged(count) => {
                   app_state.shell_count = count;
                   app_state.update_count_display();
               }
               // Handle other events...
               _ => {}
           }
       }

       std::thread::sleep(std::time::Duration::from_millis(10));
   }
   ```

6. **Clean shutdown:**
   - Send Shutdown command
   - Join background thread
   - Exit cleanly

**Environment variable:**
- RELAY_URL: Override relay server URL (default: ws://localhost:3000/ws)
  </action>
  <verify>
1. Start relay server: `cargo run --manifest-path relay-server-v2/Cargo.toml`
2. Run mac-client: `cargo run --manifest-path mac-client/Cargo.toml`
3. Verify:
   - Tray icon appears in menu bar
   - Menu shows real 6-character session code (not "------")
   - Status shows "Connected"
   - Sessions shows "0"
   - Click "Copy Session Code" - menu item changes to "Copied!" for 2 seconds, then reverts
   - Paste somewhere - should be the code
   - Stop relay server - status should change to "Disconnected"
   - Restart relay - should auto-reconnect and get new code
   - Click Quit - app exits cleanly
  </verify>
  <done>
Full integration working: tray shows real session code from relay, status updates on connect/disconnect, clipboard copy works with user-visible "Copied!" confirmation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add relay and IPC event forwarding</name>
  <files>mac-client/src/main.rs</files>
  <action>
Ensure the background thread properly forwards events from relay and IPC modules to the main thread.

The relay module emits RelayEvent, and IPC module emits IpcEvent. These need to be converted to UiEvent and sent to the main thread.

**Option A: Adapter pattern in background thread:**
Create separate forwarding tasks that read from module channels and write to ui_tx:

```rust
// In the background thread's async block:

// Forward relay events
let ui_tx_relay = ui_tx.clone();
tokio::spawn(async move {
    while let Ok(event) = relay_event_rx.recv() {
        let ui_event = match event {
            RelayEvent::Connected => UiEvent::RelayConnected,
            RelayEvent::Disconnected => UiEvent::RelayDisconnected,
            RelayEvent::SessionCode(code) => UiEvent::SessionCode(code),
            RelayEvent::BrowserConnected(id) => UiEvent::BrowserConnected(id),
            RelayEvent::BrowserDisconnected(id) => UiEvent::BrowserDisconnected(id),
            RelayEvent::Error(msg) => UiEvent::RelayError(msg),
        };
        ui_tx_relay.send(ui_event).ok();
    }
});

// Forward IPC events
let ui_tx_ipc = ui_tx.clone();
tokio::spawn(async move {
    while let Ok(event) = ipc_event_rx.recv() {
        let ui_event = match event {
            IpcEvent::SessionConnected { session_id, name } =>
                UiEvent::ShellConnected { session_id, name },
            IpcEvent::SessionDisconnected { session_id } =>
                UiEvent::ShellDisconnected { session_id },
            IpcEvent::SessionCountChanged(count) =>
                UiEvent::ShellCountChanged(count),
            IpcEvent::Error(msg) => UiEvent::IpcError(msg),
        };
        ui_tx_ipc.send(ui_event).ok();
    }
});
```

**Option B: Direct UiEvent in modules:**
Alternatively, modify relay and ipc modules to accept `Sender<UiEvent>` directly. But this couples them to the app module. Adapter pattern (Option A) is cleaner.

Use std::sync::mpsc for the module channels since they need to work with the Tokio runtime receiving end. The forwarding tasks bridge async (tokio::spawn) with sync (mpsc::recv in a loop with tokio::task::spawn_blocking or similar).

Actually, simpler approach - use tokio::sync::mpsc for module channels, and have forwarding tasks use async recv:

```rust
// Module channels (tokio::sync::mpsc)
let (relay_tx, mut relay_rx) = tokio::sync::mpsc::unbounded_channel();
let (ipc_tx, mut ipc_rx) = tokio::sync::mpsc::unbounded_channel();

// Forwarding
tokio::spawn(async move {
    while let Some(event) = relay_rx.recv().await {
        // Convert and send to ui_tx (std::sync::mpsc)
        ui_tx_relay.send(convert_relay_event(event)).ok();
    }
});
```

This requires updating relay and ipc modules to use tokio::sync::mpsc::UnboundedSender instead of std::sync::mpsc::Sender. Make this change if needed.
  </action>
  <verify>
Test the full flow:
1. Start relay, start mac-client
2. Verify session code appears in menu
3. Stop relay - verify "Disconnected" appears
4. Start relay again - verify reconnect and new code
5. The shell connection forwarding will be tested in Phase 6
  </verify>
  <done>
Event forwarding works reliably between background tasks and main thread.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cargo run --manifest-path mac-client/Cargo.toml` with relay running shows real session code
2. Connection status updates on relay connect/disconnect
3. Auto-reconnect works with exponential backoff (watch logs)
4. Copy Session Code puts code in clipboard AND shows "Copied!" confirmation for 2 seconds
5. Quit cleanly shuts down background thread
6. Unix socket exists at /tmp/terminal-remote.sock while running
</verification>

<success_criteria>
- Menu displays real session code from relay server (not placeholder)
- Status indicator shows Connected/Disconnected accurately
- Session count displays (will show 0 until Phase 6)
- Copy to clipboard works with actual session code
- Copy action shows "Copied!" confirmation that users can see (not just logging)
- Auto-reconnect works when relay restarts
- Clean shutdown via Quit menu
- No CPU spinning (10ms sleep in event loop)
</success_criteria>

<output>
After completion, create `.planning/phases/05-mac-client/05-04-SUMMARY.md`
</output>
