---
phase: 05-mac-client
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - mac-client/src/relay/mod.rs
  - mac-client/src/relay/connection.rs
  - mac-client/src/protocol.rs
  - mac-client/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "WebSocket client connects to relay server"
    - "Client sends Register message and receives session code"
    - "Connection automatically reconnects on disconnect with backoff"
  artifacts:
    - path: "mac-client/src/relay/mod.rs"
      provides: "Relay module exports"
      exports: ["RelayClient", "RelayEvent"]
    - path: "mac-client/src/relay/connection.rs"
      provides: "WebSocket connection with auto-reconnect"
      min_lines: 100
    - path: "mac-client/src/protocol.rs"
      provides: "Protocol message types compatible with relay server"
      contains: "ControlMessage"
  key_links:
    - from: "relay/connection.rs"
      to: "tokio-tungstenite"
      via: "connect_async"
      pattern: "connect_async"
    - from: "relay/connection.rs"
      to: "protocol.rs"
      via: "ControlMessage serialization"
      pattern: "ControlMessage::Register"
---

<objective>
Create the WebSocket client module for connecting to the relay server.

Purpose: Implement the relay connection with auto-reconnect capability that will be integrated into the main app in Plan 05-04. This module runs on the Tokio background thread and communicates via channels.

Output: A self-contained relay client module that connects to the relay, registers for a session code, handles disconnects with exponential backoff, and emits events via a channel.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-mac-client/05-RESEARCH.md
@.planning/phases/05-mac-client/05-01-SUMMARY.md

# Reference relay server protocol - must be compatible
@relay-server-v2/src/protocol.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create protocol types compatible with relay server</name>
  <files>mac-client/src/protocol.rs, mac-client/src/lib.rs</files>
  <action>
Create protocol.rs with ControlMessage enum that EXACTLY matches relay-server-v2/src/protocol.rs:

```rust
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ControlMessage {
    // Mac-client -> Relay
    Register { client_id: String },

    // Relay -> Mac-client
    Registered { code: String },
    BrowserConnected { browser_id: String },
    BrowserDisconnected { browser_id: String },

    // Browser -> Relay (not used by mac-client but included for completeness)
    Auth { session_code: String },

    // Relay -> Browser (not used by mac-client)
    AuthSuccess,
    AuthFailed { reason: String },

    // Bidirectional
    Error { message: String },
}
```

The serde attributes MUST match: `tag = "type"`, `rename_all = "snake_case"`.

Update lib.rs to export the protocol module:
```rust
pub mod protocol;
```
  </action>
  <verify>
Write a quick test in protocol.rs:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_register_serialization() {
        let msg = ControlMessage::Register { client_id: "test".into() };
        let json = serde_json::to_string(&msg).unwrap();
        assert!(json.contains("\"type\":\"register\""));
    }
}
```
Run `cargo test --manifest-path mac-client/Cargo.toml` - test should pass.
  </verify>
  <done>
Protocol types match relay server format, serialization test passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create relay client with auto-reconnect</name>
  <files>mac-client/src/relay/mod.rs, mac-client/src/relay/connection.rs, mac-client/src/lib.rs</files>
  <action>
Create relay/ directory and modules.

**relay/mod.rs:**
```rust
mod connection;
pub use connection::{RelayClient, RelayEvent};
```

**relay/connection.rs:**

Define RelayEvent enum for communication with main thread:
```rust
pub enum RelayEvent {
    Connected,
    Disconnected,
    SessionCode(String),
    BrowserConnected(String),
    BrowserDisconnected(String),
    Error(String),
}
```

Create RelayClient struct:
- relay_url: String (e.g., "ws://localhost:3000/ws")
- client_id: String (UUID generated once)
- event_tx: std::sync::mpsc::Sender<RelayEvent>
- reconnect_attempts: counter

Implement methods:
1. `new(relay_url: String, event_tx: Sender<RelayEvent>) -> Self`
   - Generate client_id using uuid::Uuid::new_v4()

2. `async fn run(&mut self)` - Main loop with reconnect:
   ```rust
   loop {
       match self.connect_and_run().await {
           Ok(()) => {} // Clean disconnect, reconnect immediately
           Err(e) => {
               tracing::error!("Connection error: {}", e);
           }
       }

       self.event_tx.send(RelayEvent::Disconnected).ok();

       // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 32s max
       let delay_secs = (2u64).pow(self.reconnect_attempts.min(5));
       tracing::info!("Reconnecting in {}s...", delay_secs);
       tokio::time::sleep(Duration::from_secs(delay_secs)).await;
       self.reconnect_attempts += 1;
   }
   ```

3. `async fn connect_and_run(&mut self) -> Result<(), Box<dyn Error + Send + Sync>>`:
   - Connect using tokio_tungstenite::connect_async(&self.relay_url)
   - Send RelayEvent::Connected
   - Reset reconnect_attempts to 0
   - Send Register message with client_id
   - Loop reading messages:
     - Text message: Parse as ControlMessage, handle Registered/BrowserConnected/etc
     - Binary message: Forward to shell sessions (placeholder for Phase 6)
     - Close/Error: Return to trigger reconnect

Message handling:
- ControlMessage::Registered { code } -> send RelayEvent::SessionCode(code)
- ControlMessage::BrowserConnected { browser_id } -> send RelayEvent::BrowserConnected(browser_id)
- ControlMessage::BrowserDisconnected { browser_id } -> send RelayEvent::BrowserDisconnected(browser_id)
- ControlMessage::Error { message } -> send RelayEvent::Error(message)

Update lib.rs to export relay module.
  </action>
  <verify>
Create a simple test that can run without a server (unit test for message parsing):
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_relay_event_variants() {
        let _connected = RelayEvent::Connected;
        let _code = RelayEvent::SessionCode("ABC123".into());
        // Compile check - events are constructible
    }
}
```

Run `cargo check --manifest-path mac-client/Cargo.toml` to verify compilation.

For integration test (manual):
1. Start relay server: `cargo run --manifest-path relay-server-v2/Cargo.toml`
2. Create a test binary that creates RelayClient and runs it
3. Verify it connects and receives session code
  </verify>
  <done>
RelayClient module compiles, implements connect + register + auto-reconnect with backoff.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cargo check --manifest-path mac-client/Cargo.toml` passes
2. `cargo test --manifest-path mac-client/Cargo.toml` passes (protocol test)
3. Protocol messages serialize to same format as relay server
4. RelayClient has run() method with reconnect loop
</verification>

<success_criteria>
- Protocol types exactly match relay-server-v2/src/protocol.rs
- RelayClient connects to relay, sends Register, receives Registered
- Auto-reconnect with exponential backoff (1s, 2s, 4s... 32s max)
- Events communicated via std::sync::mpsc channel (not tokio::sync)
- Module is self-contained, ready for integration in 05-04
</success_criteria>

<output>
After completion, create `.planning/phases/05-mac-client/05-02-SUMMARY.md`
</output>
