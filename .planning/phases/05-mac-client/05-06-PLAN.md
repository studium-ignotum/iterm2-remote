---
phase: 05-mac-client
plan: 06
type: execute
wave: 4
depends_on: ["05-04"]
files_modified:
  - mac-client/src/relay/connection.rs
  - mac-client/src/ipc/mod.rs
  - mac-client/src/ipc/session.rs
  - mac-client/src/main.rs
  - mac-client/src/app.rs
autonomous: true

must_haves:
  truths:
    - "Terminal data from shell sessions is forwarded to relay"
    - "Terminal data from relay is forwarded to shell sessions"
    - "Binary data flows bidirectionally between IPC and WebSocket"
  artifacts:
    - path: "mac-client/src/relay/connection.rs"
      provides: "Binary data send/receive capabilities"
      contains: "send_binary"
    - path: "mac-client/src/ipc/mod.rs"
      provides: "Stream storage and data reading"
      contains: "read_terminal_data"
    - path: "mac-client/src/app.rs"
      provides: "Data forwarding events"
      contains: "TerminalData"
  key_links:
    - from: "ipc/mod.rs"
      to: "relay/connection.rs"
      via: "terminal data channel"
      pattern: "TerminalData"
    - from: "relay/connection.rs"
      to: "ipc sessions"
      via: "binary message routing"
      pattern: "Binary.*session_id"
---

<objective>
Implement bidirectional terminal data forwarding between shell sessions and relay.

Purpose: The mac-client must forward terminal data from locally connected shells to the relay server (for browser display), and forward input from the relay (browser keystrokes) back to the shells. This completes the success criterion "Terminal data from local sessions is forwarded to relay."

Output: Working data pipeline where bytes flow from IPC sessions to WebSocket relay and vice versa.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-mac-client/05-RESEARCH.md
@.planning/phases/05-mac-client/05-02-SUMMARY.md
@.planning/phases/05-mac-client/05-03-SUMMARY.md
@.planning/phases/05-mac-client/05-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add terminal data events and relay binary methods</name>
  <files>mac-client/src/app.rs, mac-client/src/relay/connection.rs</files>
  <action>
**Update app.rs with terminal data events:**

Add new event variants to UiEvent:
```rust
pub enum UiEvent {
    // ... existing variants ...

    // Terminal data from IPC (shell -> relay)
    TerminalDataFromShell { session_id: String, data: Vec<u8> },

    // Terminal data from relay (browser -> shell)
    TerminalDataFromRelay { session_id: String, data: Vec<u8> },
}
```

Add command variant for sending data to relay:
```rust
pub enum BackgroundCommand {
    Shutdown,
    // Send terminal data to relay (shell -> browser)
    SendTerminalData { session_id: String, data: Vec<u8> },
    // Send terminal data to shell (browser -> shell)
    SendToShell { session_id: String, data: Vec<u8> },
}
```

**Update relay/connection.rs to handle binary data:**

1. Add method to send binary data to relay:
```rust
impl RelayClient {
    /// Send terminal data to relay for a specific session
    pub async fn send_terminal_data(&mut self, session_id: &str, data: &[u8]) -> Result<(), Error> {
        // Frame format: 1 byte session_id length + session_id + data
        let mut frame = Vec::with_capacity(1 + session_id.len() + data.len());
        frame.push(session_id.len() as u8);
        frame.extend_from_slice(session_id.as_bytes());
        frame.extend_from_slice(data);

        if let Some(ref mut ws) = self.ws_stream {
            ws.send(Message::Binary(frame)).await?;
        }
        Ok(())
    }
}
```

2. Handle incoming binary messages in the message loop:
```rust
// In connect_and_run, handle binary messages:
Message::Binary(data) => {
    // Parse frame: 1 byte length + session_id + terminal_data
    if data.len() > 1 {
        let id_len = data[0] as usize;
        if data.len() > 1 + id_len {
            let session_id = String::from_utf8_lossy(&data[1..1+id_len]).to_string();
            let terminal_data = data[1+id_len..].to_vec();
            self.event_tx.send(RelayEvent::TerminalData {
                session_id,
                data: terminal_data,
            }).ok();
        }
    }
}
```

3. Add TerminalData variant to RelayEvent:
```rust
pub enum RelayEvent {
    // ... existing variants ...
    TerminalData { session_id: String, data: Vec<u8> },
}
```

4. Add command channel to RelayClient for receiving commands:
```rust
pub struct RelayClient {
    // ... existing fields ...
    command_rx: Option<tokio::sync::mpsc::UnboundedReceiver<RelayCommand>>,
}

pub enum RelayCommand {
    SendTerminalData { session_id: String, data: Vec<u8> },
}
```

Update new() to accept command receiver. In run loop, select! on both WebSocket messages and command channel.
  </action>
  <verify>
Run `cargo check --manifest-path mac-client/Cargo.toml` - compiles without errors.
  </verify>
  <done>
RelayClient can send and receive binary terminal data. Events and commands defined for data flow.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add stream storage and data reading to IpcServer</name>
  <files>mac-client/src/ipc/mod.rs, mac-client/src/ipc/session.rs</files>
  <action>
**Update session.rs to hold write half of stream:**

```rust
use tokio::net::unix::OwnedWriteHalf;

pub struct Session {
    pub id: String,
    pub name: String,
    pub connected_at: Instant,
    pub write_half: OwnedWriteHalf,  // For sending data back to shell
}

impl Session {
    pub fn new(id: String, name: String, write_half: OwnedWriteHalf) -> Self {
        Self {
            id,
            name,
            connected_at: Instant::now(),
            write_half,
        }
    }

    /// Write terminal data to the shell
    pub async fn write(&mut self, data: &[u8]) -> std::io::Result<()> {
        use tokio::io::AsyncWriteExt;
        self.write_half.write_all(data).await
    }
}
```

**Update ipc/mod.rs to read terminal data:**

1. Add IpcEvent variant for terminal data:
```rust
pub enum IpcEvent {
    // ... existing variants ...
    TerminalData { session_id: String, data: Vec<u8> },
}
```

2. Add command type for writing to sessions:
```rust
pub enum IpcCommand {
    WriteToSession { session_id: String, data: Vec<u8> },
}
```

3. Update handle_connection to split stream and spawn read task:
```rust
async fn handle_connection(
    stream: UnixStream,
    session_id: String,
    event_tx: Sender<IpcEvent>,
) {
    let (read_half, write_half) = stream.into_split();

    // Read registration message first
    let mut reader = BufReader::new(read_half);
    let mut line = String::new();
    if reader.read_line(&mut line).await.is_err() {
        return;
    }

    // Parse registration
    let registration: ShellRegistration = match serde_json::from_str(&line) {
        Ok(r) => r,
        Err(_) => return,
    };

    // Send connected event
    event_tx.send(IpcEvent::SessionConnected {
        session_id: session_id.clone(),
        name: registration.name.clone(),
    }).ok();

    // Spawn terminal data reading loop
    let event_tx_clone = event_tx.clone();
    let session_id_clone = session_id.clone();
    tokio::spawn(async move {
        let mut buf = [0u8; 4096];
        loop {
            match reader.read(&mut buf).await {
                Ok(0) => break,  // EOF - session disconnected
                Ok(n) => {
                    event_tx_clone.send(IpcEvent::TerminalData {
                        session_id: session_id_clone.clone(),
                        data: buf[..n].to_vec(),
                    }).ok();
                }
                Err(_) => break,
            }
        }
        // Send disconnected event
        event_tx_clone.send(IpcEvent::SessionDisconnected {
            session_id: session_id_clone,
        }).ok();
    });

    // Store write_half in sessions map for later use
    // This requires sessions to be accessible - use Arc<Mutex<HashMap>>
}
```

4. Make sessions accessible for writing:
```rust
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct IpcServer {
    listener: UnixListener,
    sessions: Arc<Mutex<HashMap<String, Session>>>,
    event_tx: Sender<IpcEvent>,
    command_rx: tokio::sync::mpsc::UnboundedReceiver<IpcCommand>,
}

impl IpcServer {
    pub async fn write_to_session(&self, session_id: &str, data: &[u8]) -> std::io::Result<()> {
        let mut sessions = self.sessions.lock().await;
        if let Some(session) = sessions.get_mut(session_id) {
            session.write(data).await
        } else {
            Err(std::io::Error::new(std::io::ErrorKind::NotFound, "Session not found"))
        }
    }
}
```

5. Update run() to handle IpcCommand for writing:
```rust
pub async fn run(&mut self) {
    loop {
        tokio::select! {
            result = self.listener.accept() => {
                // Handle new connection
            }
            Some(cmd) = self.command_rx.recv() => {
                match cmd {
                    IpcCommand::WriteToSession { session_id, data } => {
                        if let Err(e) = self.write_to_session(&session_id, &data).await {
                            tracing::warn!("Failed to write to session {}: {}", session_id, e);
                        }
                    }
                }
            }
        }
    }
}
```
  </action>
  <verify>
Run `cargo check --manifest-path mac-client/Cargo.toml` - compiles.
Run `cargo test --manifest-path mac-client/Cargo.toml` - existing tests pass.
  </verify>
  <done>
IpcServer reads terminal data from shell connections and can write data back to sessions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire up bidirectional data flow in main.rs</name>
  <files>mac-client/src/main.rs</files>
  <action>
Update main.rs to connect the data pipelines:

**1. Create command channels for both modules:**
```rust
let (relay_cmd_tx, relay_cmd_rx) = tokio::sync::mpsc::unbounded_channel::<RelayCommand>();
let (ipc_cmd_tx, ipc_cmd_rx) = tokio::sync::mpsc::unbounded_channel::<IpcCommand>();
```

**2. Pass command receivers to modules:**
```rust
let mut relay = RelayClient::new(relay_url, relay_event_tx, relay_cmd_rx);
let mut ipc = IpcServer::new(ipc_event_tx, ipc_cmd_rx).await?;
```

**3. Forward IPC terminal data to relay:**
In the event forwarding task for IPC events:
```rust
IpcEvent::TerminalData { session_id, data } => {
    // Forward to relay
    relay_cmd_tx.send(RelayCommand::SendTerminalData {
        session_id,
        data,
    }).ok();
}
```

**4. Forward relay terminal data to IPC:**
In the event forwarding task for relay events:
```rust
RelayEvent::TerminalData { session_id, data } => {
    // Forward to IPC session
    ipc_cmd_tx.send(IpcCommand::WriteToSession {
        session_id,
        data,
    }).ok();
}
```

**5. Update UiEvent handling (optional - for logging/debugging):**
The terminal data doesn't need to go to the main UI thread unless we want to show activity indicators. Keep the data flow in the background thread for efficiency.

The architecture becomes:
```
Shell -> UnixStream -> IpcServer (read) -> IpcEvent::TerminalData
      -> relay_cmd_tx -> RelayClient -> WebSocket -> Relay Server

Relay Server -> WebSocket -> RelayClient (recv) -> RelayEvent::TerminalData
             -> ipc_cmd_tx -> IpcServer -> Session.write -> UnixStream -> Shell
```
  </action>
  <verify>
Manual test (requires Phase 6 shell integration to fully test, but verify the plumbing):

1. Start relay server
2. Run mac-client
3. Use netcat to simulate a shell: `echo '{"name":"test","shell":"nc","pid":1234}' | nc -U /tmp/terminal-remote.sock`
4. Send some bytes after the registration
5. Check relay server logs - should show binary data received
6. (Full test will be in Phase 6 when actual shell integration exists)

Run `cargo check` and `cargo build` to ensure compilation.
  </verify>
  <done>
Bidirectional terminal data forwarding wired up: IPC -> Relay and Relay -> IPC.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cargo build --manifest-path mac-client/Cargo.toml` succeeds
2. IpcServer reads data from connected streams continuously
3. RelayClient can send and receive binary messages
4. Data flows bidirectionally through the command channels
5. No CPU spinning (async I/O with proper select!)
</verification>

<success_criteria>
- IpcServer stores write halves of streams for bidirectional communication
- IpcServer spawns read tasks for each session that emit TerminalData events
- RelayClient has send_terminal_data method for outbound binary data
- RelayClient parses incoming binary messages and emits TerminalData events
- Command channels connect the two modules for data forwarding
- Phase 5 success criterion met: "Terminal data from local sessions is forwarded to relay"
</success_criteria>

<output>
After completion, create `.planning/phases/05-mac-client/05-06-SUMMARY.md`
</output>
