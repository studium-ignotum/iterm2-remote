---
phase: 05-mac-client
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - mac-client/src/ipc/mod.rs
  - mac-client/src/ipc/session.rs
  - mac-client/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Unix socket listens at /tmp/terminal-remote.sock"
    - "Stale socket file is cleaned up on startup"
    - "Session count is tracked and reported via channel"
  artifacts:
    - path: "mac-client/src/ipc/mod.rs"
      provides: "IPC module with socket listener"
      exports: ["IpcServer", "IpcEvent"]
    - path: "mac-client/src/ipc/session.rs"
      provides: "Session tracking"
      contains: "Session"
  key_links:
    - from: "ipc/mod.rs"
      to: "tokio::net::UnixListener"
      via: "socket binding"
      pattern: "UnixListener::bind"
    - from: "ipc/mod.rs"
      to: "main thread"
      via: "IpcEvent channel"
      pattern: "IpcEvent::SessionCountChanged"
---

<objective>
Create the Unix socket IPC module for shell integration connections.

Purpose: Implement the local IPC server that shell integration (Phase 6) will connect to. This module listens on a Unix domain socket, tracks connected sessions, and reports session count changes to the main thread.

Output: A self-contained IPC module that manages the Unix socket and session tracking, ready for integration in Plan 05-04.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-mac-client/05-RESEARCH.md
@.planning/phases/05-mac-client/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IPC server with Unix socket listener</name>
  <files>mac-client/src/ipc/mod.rs, mac-client/src/lib.rs</files>
  <action>
Create ipc/ directory and mod.rs.

**ipc/mod.rs:**

Define IpcEvent enum for communication with main thread:
```rust
pub enum IpcEvent {
    SessionConnected { session_id: String, name: String },
    SessionDisconnected { session_id: String },
    SessionCountChanged(usize),
    Error(String),
}
```

Define socket path constant:
```rust
pub const SOCKET_PATH: &str = "/tmp/terminal-remote.sock";
```

Create IpcServer struct:
- listener: tokio::net::UnixListener
- sessions: HashMap<String, Session>  (will use session.rs)
- event_tx: std::sync::mpsc::Sender<IpcEvent>

Implement:
1. `async fn new(event_tx: Sender<IpcEvent>) -> std::io::Result<Self>`:
   - Remove existing socket file if it exists (stale socket cleanup)
   - Bind UnixListener to SOCKET_PATH
   - Log success with tracing::info!

2. `async fn run(&mut self)`:
   - Loop accepting connections with listener.accept()
   - For each connection, spawn a task to handle it (tokio::spawn)
   - Track sessions in HashMap
   - Send IpcEvent::SessionCountChanged on connect/disconnect

3. `async fn handle_connection(&mut self, stream: UnixStream)`:
   - Read initial registration message from shell (JSON with session name)
   - Generate session_id (UUID)
   - Add to sessions map
   - Send IpcEvent::SessionConnected
   - Send IpcEvent::SessionCountChanged
   - Wait for disconnect (stream closes)
   - Remove from sessions
   - Send IpcEvent::SessionDisconnected
   - Send IpcEvent::SessionCountChanged

Implement Drop trait to clean up socket file:
```rust
impl Drop for IpcServer {
    fn drop(&mut self) {
        let _ = std::fs::remove_file(SOCKET_PATH);
    }
}
```

Note: Full bidirectional terminal data forwarding comes in Plan 05-04 integration and Phase 6. This plan focuses on connection management and session tracking.

Update lib.rs to export ipc module.
  </action>
  <verify>
Run `cargo check --manifest-path mac-client/Cargo.toml` - should compile.

Manual test:
1. Run the mac-client (once integrated)
2. Verify socket file exists: `ls -la /tmp/terminal-remote.sock`
3. Test connection: `nc -U /tmp/terminal-remote.sock` (will connect and likely fail to parse, but proves socket works)
4. Stop mac-client, verify socket file is cleaned up
  </verify>
  <done>
IpcServer compiles, implements socket binding with stale cleanup and session tracking skeleton.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Session type for tracking connected shells</name>
  <files>mac-client/src/ipc/session.rs, mac-client/src/ipc/mod.rs</files>
  <action>
Create session.rs with Session struct:

```rust
use tokio::net::UnixStream;
use std::time::Instant;

pub struct Session {
    pub id: String,
    pub name: String,
    pub connected_at: Instant,
    // stream will be used for bidirectional communication in Phase 6
    // For now, we just track metadata
}

impl Session {
    pub fn new(id: String, name: String) -> Self {
        Self {
            id,
            name,
            connected_at: Instant::now(),
        }
    }

    pub fn duration_secs(&self) -> u64 {
        self.connected_at.elapsed().as_secs()
    }
}
```

Update mod.rs to include:
```rust
mod session;
pub use session::Session;
```

Note: The actual UnixStream for each session will be stored separately when we implement full data forwarding. For now, Session is just metadata.

Define the expected registration message format (for shell integration to use in Phase 6):
```rust
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
pub struct ShellRegistration {
    pub name: String,      // e.g., "zsh - ~/project"
    pub shell: String,     // e.g., "zsh", "bash"
    pub pid: u32,          // Process ID
}
```

This gives Phase 6 a clear contract for how shells register.
  </action>
  <verify>
Run `cargo check --manifest-path mac-client/Cargo.toml` - compiles without errors.

Run `cargo test --manifest-path mac-client/Cargo.toml` - any existing tests pass.
  </verify>
  <done>
Session type exists with id, name, connected_at. ShellRegistration message format defined for Phase 6.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cargo check --manifest-path mac-client/Cargo.toml` passes
2. IpcServer struct has new() and run() methods
3. Session tracking with HashMap
4. Socket cleanup on drop
5. IpcEvent enum defined for main thread communication
</verification>

<success_criteria>
- Unix socket binds to /tmp/terminal-remote.sock
- Stale socket removed on startup (prevents "address in use" errors)
- Socket file removed on clean shutdown (Drop impl)
- Session struct tracks id, name, connected_at
- IpcEvent channel communicates session changes to main thread
- ShellRegistration contract defined for Phase 6
</success_criteria>

<output>
After completion, create `.planning/phases/05-mac-client/05-03-SUMMARY.md`
</output>
