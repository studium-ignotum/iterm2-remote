---
phase: 06-shell-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shell-integration/init.zsh
  - shell-integration/init.bash
  - shell-integration/init.fish
autonomous: true

must_haves:
  truths:
    - "Sourcing init.zsh in a shell sends registration to mac-client"
    - "Sourcing init.bash in a shell sends registration to mac-client"
    - "Sourcing init.fish in a shell sends registration to mac-client"
    - "Session name updates live when directory changes (cd triggers rename)"
    - "Session stays active while shell is running"
    - "When mac-client not running, script prints note and completes under 100ms"
    - "Disconnect warning printed once when mac-client quits/crashes"
    - "Auto-reconnect happens when mac-client comes back"
  artifacts:
    - path: "shell-integration/init.zsh"
      provides: "Zsh shell integration"
      min_lines: 80
      contains: "add-zsh-hook chpwd"
    - path: "shell-integration/init.bash"
      provides: "Bash shell integration"
      min_lines: 70
      contains: "PROMPT_COMMAND"
    - path: "shell-integration/init.fish"
      provides: "Fish shell integration"
      min_lines: 70
      contains: "--on-variable PWD"
  key_links:
    - from: "shell-integration/init.zsh"
      to: "/tmp/terminal-remote.sock"
      via: "nc -U socket connection"
      pattern: "nc.*-U.*/tmp/terminal-remote"
    - from: "shell-integration/init.bash"
      to: "/tmp/terminal-remote.sock"
      via: "nc -U socket connection"
      pattern: "nc.*-U.*/tmp/terminal-remote"
    - from: "shell-integration/init.fish"
      to: "/tmp/terminal-remote.sock"
      via: "nc -U socket connection"
      pattern: "nc.*-U.*/tmp/terminal-remote"
---

<objective>
Create shell integration scripts for zsh, bash, and fish that connect terminal sessions to mac-client via Unix domain socket, with live directory tracking, graceful degradation, and auto-reconnection.

Purpose: Enable any terminal session to register with mac-client for remote access, fulfilling the universal terminal support goal of v2.0.

Output: Three init scripts in shell-integration/ directory ready for installation to ~/.terminal-remote/
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-shell-integration/06-CONTEXT.md
@.planning/phases/06-shell-integration/06-RESEARCH.md
@.planning/phases/05-mac-client/05-03-SUMMARY.md
@mac-client/src/ipc/session.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zsh integration script</name>
  <files>shell-integration/init.zsh</files>
  <action>
Create `shell-integration/init.zsh` with the following functionality:

**Configuration:**
- Socket path: `/tmp/terminal-remote.sock`
- Session name format: `${PWD##*/} [$$]` (directory basename + PID)
- Reconnect interval: 5 seconds

**Core functions:**
1. `_terminal_remote_session_name()` - Returns "dirname [PID]" format
2. `_terminal_remote_json_escape()` - Escapes strings for JSON (backslash, quote, newline, tab)
3. `_terminal_remote_connect()` - Attempts socket connection
4. `_terminal_remote_send_update()` - Sends rename message on directory change

**Connection approach (persistent background process):**
- Use a coprocess or background subshell that holds the socket open
- Send registration JSON: `{"name":"...","shell":"zsh","pid":$$}`
- Keep nc running in background with `cat` blocking on its stdin
- Store background PID in `_TERMINAL_REMOTE_BG_PID`

**Startup logic (CRITICAL - must print message when mac-client not running):**
```zsh
_terminal_remote_init() {
  # Fast check: socket file exists?
  if [[ ! -S "$_TERMINAL_REMOTE_SOCKET" ]]; then
    echo "Terminal Remote not running"
    _terminal_remote_start_watcher
    return 0
  fi

  _terminal_remote_connect
  if (( _TERMINAL_REMOTE_CONNECTED )); then
    echo "Connected to Terminal Remote"
  fi
}
```

**Directory change hook (CRITICAL - locked decision):**
```zsh
_terminal_remote_chpwd() {
  (( _TERMINAL_REMOTE_CONNECTED )) || return
  # Fire-and-forget: don't wait for response
  _terminal_remote_send_update &!
}
add-zsh-hook chpwd _terminal_remote_chpwd
```

The `_terminal_remote_send_update` function sends:
```json
{"type":"rename","name":"new-dir [PID]"}
```

**Background watcher for auto-reconnect:**
```zsh
_terminal_remote_start_watcher() {
  # Already watching?
  [[ -n "$_TERMINAL_REMOTE_WATCHER_PID" ]] && return

  {
    while true; do
      sleep 5
      if [[ -S "$_TERMINAL_REMOTE_SOCKET" ]] && (( ! _TERMINAL_REMOTE_CONNECTED )); then
        _terminal_remote_connect
        if (( _TERMINAL_REMOTE_CONNECTED )); then
          echo "Connected to Terminal Remote"
        fi
      fi
    done
  } &!
  _TERMINAL_REMOTE_WATCHER_PID=$!
}
```

**Disconnect detection and warning:**
When the background nc process dies (mac-client quit/crash), print warning once:
```zsh
_terminal_remote_check_connection() {
  if (( _TERMINAL_REMOTE_CONNECTED )) && [[ -n "$_TERMINAL_REMOTE_BG_PID" ]]; then
    if ! kill -0 "$_TERMINAL_REMOTE_BG_PID" 2>/dev/null; then
      _TERMINAL_REMOTE_CONNECTED=0
      echo "Terminal Remote disconnected"
      _terminal_remote_start_watcher
    fi
  fi
}
```
Call this in precmd (lightweight - just a kill -0 check, no I/O).

**Exit cleanup:**
```zsh
_terminal_remote_zshexit() {
  (( _TERMINAL_REMOTE_CONNECTED )) || return
  # Kill background process holding socket
  [[ -n "$_TERMINAL_REMOTE_BG_PID" ]] && kill "$_TERMINAL_REMOTE_BG_PID" 2>/dev/null
  [[ -n "$_TERMINAL_REMOTE_WATCHER_PID" ]] && kill "$_TERMINAL_REMOTE_WATCHER_PID" 2>/dev/null
}
```

**Register hooks using add-zsh-hook:**
```zsh
autoload -Uz add-zsh-hook
add-zsh-hook chpwd _terminal_remote_chpwd
add-zsh-hook precmd _terminal_remote_check_connection
zshexit() { _terminal_remote_zshexit }
```

**Important implementation notes:**
- Use `&!` (background + disown) for fire-and-forget operations
- Suppress all error output to stderr (2>/dev/null)
- The socket existence check is instant (filesystem stat)
- chpwd hook sends update asynchronously (no latency impact)
- precmd hook only does kill -0 check (microseconds, no I/O)
  </action>
  <verify>
Run: `zsh -c 'source shell-integration/init.zsh && echo $_TERMINAL_REMOTE_SOCKET'` outputs `/tmp/terminal-remote.sock`

Verify chpwd hook registered: `zsh -c 'source shell-integration/init.zsh && typeset -f _terminal_remote_chpwd'` shows function definition

Verify startup message when no socket: Remove socket first, then `zsh -c 'source shell-integration/init.zsh'` prints "Terminal Remote not running"
  </verify>
  <done>
init.zsh exists with: connection logic, JSON escaping, exit cleanup, chpwd hook for live directory tracking, precmd hook for disconnect detection, background watcher for auto-reconnect, startup message when mac-client not running. Functions load without errors. Socket path constant defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Bash integration script</name>
  <files>shell-integration/init.bash</files>
  <action>
Create `shell-integration/init.bash` with equivalent functionality to init.zsh:

**Configuration:**
- Same socket path and session name format
- Use `$$` for PID (works in bash)
- Track previous directory in `_TERMINAL_REMOTE_PREVPWD`

**Core functions (bash syntax):**
1. `_terminal_remote_session_name()` - Same logic, bash-compatible
2. `_terminal_remote_json_escape()` - Use bash string substitution
3. `_terminal_remote_connect()` - Background process approach
4. `_terminal_remote_send_update()` - Sends rename message

**Connection approach:**
```bash
_terminal_remote_connect() {
  local name
  name=$(_terminal_remote_json_escape "$(_terminal_remote_session_name)")
  local msg="{\"name\":\"${name}\",\"shell\":\"bash\",\"pid\":$$}"

  # Background process: send registration and keep connection open
  {
    echo "$msg"
    # Block forever (connection stays open until killed)
    cat
  } | nc -U "$_TERMINAL_REMOTE_SOCKET" 2>/dev/null &
  _TERMINAL_REMOTE_BG_PID=$!
  disown $_TERMINAL_REMOTE_BG_PID 2>/dev/null
  _TERMINAL_REMOTE_CONNECTED=1
}
```

**Directory change detection via PROMPT_COMMAND (CRITICAL - locked decision):**
```bash
_terminal_remote_chpwd_hook() {
  if [[ "$_TERMINAL_REMOTE_PREVPWD" != "$PWD" ]]; then
    _TERMINAL_REMOTE_PREVPWD="$PWD"
    if [[ $_TERMINAL_REMOTE_CONNECTED -eq 1 ]]; then
      _terminal_remote_send_update
    fi
  fi
}
```

The `_terminal_remote_send_update` function sends:
```json
{"type":"rename","name":"new-dir [PID]"}
```
as a fire-and-forget background operation.

**Startup logic (CRITICAL - must print message when mac-client not running):**
```bash
_terminal_remote_init() {
  if [[ ! -S "$_TERMINAL_REMOTE_SOCKET" ]]; then
    echo "Terminal Remote not running"
    _terminal_remote_start_watcher
    return 0
  fi
  _terminal_remote_connect
  [[ $_TERMINAL_REMOTE_CONNECTED -eq 1 ]] && echo "Connected to Terminal Remote"
}
```

**Background watcher for auto-reconnect:**
```bash
_terminal_remote_start_watcher() {
  [[ -n "$_TERMINAL_REMOTE_WATCHER_PID" ]] && return
  (
    while true; do
      sleep 5
      if [[ -S "$_TERMINAL_REMOTE_SOCKET" ]] && [[ $_TERMINAL_REMOTE_CONNECTED -ne 1 ]]; then
        _terminal_remote_connect
        [[ $_TERMINAL_REMOTE_CONNECTED -eq 1 ]] && echo "Connected to Terminal Remote"
      fi
    done
  ) &
  _TERMINAL_REMOTE_WATCHER_PID=$!
  disown $_TERMINAL_REMOTE_WATCHER_PID 2>/dev/null
}
```

**Disconnect detection in PROMPT_COMMAND:**
```bash
_terminal_remote_check_connection() {
  if [[ $_TERMINAL_REMOTE_CONNECTED -eq 1 ]] && [[ -n "$_TERMINAL_REMOTE_BG_PID" ]]; then
    if ! kill -0 "$_TERMINAL_REMOTE_BG_PID" 2>/dev/null; then
      _TERMINAL_REMOTE_CONNECTED=0
      echo "Terminal Remote disconnected"
      _terminal_remote_start_watcher
    fi
  fi
}
```

**Combined PROMPT_COMMAND hook:**
```bash
_terminal_remote_prompt_hook() {
  _terminal_remote_check_connection
  _terminal_remote_chpwd_hook
}

# Append to PROMPT_COMMAND safely
PROMPT_COMMAND="_terminal_remote_prompt_hook${PROMPT_COMMAND:+;$PROMPT_COMMAND}"
```

**Exit cleanup using trap:**
```bash
_terminal_remote_cleanup() {
  [[ $_TERMINAL_REMOTE_CONNECTED -eq 1 ]] || return
  [[ -n "$_TERMINAL_REMOTE_BG_PID" ]] && kill "$_TERMINAL_REMOTE_BG_PID" 2>/dev/null
  [[ -n "$_TERMINAL_REMOTE_WATCHER_PID" ]] && kill "$_TERMINAL_REMOTE_WATCHER_PID" 2>/dev/null
}
trap '_terminal_remote_cleanup' EXIT
```

**Important:**
- Use `( ... ) &` subshell for cleaner backgrounding
- `disown` prevents job completion messages
- Test with both bash 3.2 (macOS default) and bash 5.x
  </action>
  <verify>
Run: `bash --norc -c 'source shell-integration/init.bash && echo $_TERMINAL_REMOTE_SOCKET'` outputs `/tmp/terminal-remote.sock`

Check function: `bash --norc -c 'source shell-integration/init.bash && type _terminal_remote_chpwd_hook'`

Verify startup message: `rm -f /tmp/terminal-remote.sock && bash --norc -c 'source shell-integration/init.bash'` prints "Terminal Remote not running"
  </verify>
  <done>
init.bash exists with: connection logic, JSON escaping, EXIT trap, PROMPT_COMMAND with directory change detection, disconnect detection, background watcher for auto-reconnect, startup message when mac-client not running. Functions load without errors in bash 3.2+.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Fish integration script</name>
  <files>shell-integration/init.fish</files>
  <action>
Create `shell-integration/init.fish` with fish shell syntax:

**Configuration:**
```fish
set -g _TERMINAL_REMOTE_SOCKET "/tmp/terminal-remote.sock"
set -g _TERMINAL_REMOTE_CONNECTED 0
set -g _TERMINAL_REMOTE_PID %self
set -g _TERMINAL_REMOTE_BG_PID ""
set -g _TERMINAL_REMOTE_WATCHER_PID ""
```

**Core functions (fish syntax):**
1. `_terminal_remote_session_name` - Use `basename $PWD` and `%self`
2. `_terminal_remote_json_escape` - Use `string replace` for escaping
3. `_terminal_remote_connect` - Fish backgrounding
4. `_terminal_remote_send_update` - Sends rename message

**JSON escape in fish:**
```fish
function _terminal_remote_json_escape
  string replace -a '\\' '\\\\' -- $argv[1] | \
  string replace -a '"' '\\"' | \
  string replace -a \n '\\n' | \
  string replace -a \t '\\t'
end
```

**Connection:**
```fish
function _terminal_remote_connect
  set -l name (_terminal_remote_json_escape (_terminal_remote_session_name))
  set -l msg "{\"name\":\"$name\",\"shell\":\"fish\",\"pid\":$_TERMINAL_REMOTE_PID}"

  # Use fish's job control for background process
  begin
    echo $msg
    cat  # Block to keep connection open
  end | nc -U "$_TERMINAL_REMOTE_SOCKET" 2>/dev/null &
  set -g _TERMINAL_REMOTE_BG_PID (jobs -lp | tail -1)
  disown $_TERMINAL_REMOTE_BG_PID 2>/dev/null
  set -g _TERMINAL_REMOTE_CONNECTED 1
end
```

**Directory change hook (CRITICAL - locked decision):**
```fish
function _terminal_remote_chpwd --on-variable PWD
  test $_TERMINAL_REMOTE_CONNECTED -eq 1; or return
  _terminal_remote_send_update
end
```

The `_terminal_remote_send_update` function sends:
```json
{"type":"rename","name":"new-dir [PID]"}
```
as a fire-and-forget background operation.

**Startup logic (CRITICAL - must print message when mac-client not running):**
```fish
function _terminal_remote_init
  if not test -S "$_TERMINAL_REMOTE_SOCKET"
    echo "Terminal Remote not running"
    _terminal_remote_start_watcher
    return 0
  end
  _terminal_remote_connect
  test $_TERMINAL_REMOTE_CONNECTED -eq 1; and echo "Connected to Terminal Remote"
end
```

**Background watcher for auto-reconnect:**
```fish
function _terminal_remote_start_watcher
  test -n "$_TERMINAL_REMOTE_WATCHER_PID"; and return
  fish -c '
    while true
      sleep 5
      if test -S "'$_TERMINAL_REMOTE_SOCKET'" -a "'$_TERMINAL_REMOTE_CONNECTED'" -ne 1
        # Signal main shell somehow or just try to connect
      end
    end
  ' &
  set -g _TERMINAL_REMOTE_WATCHER_PID (jobs -lp | tail -1)
  disown $_TERMINAL_REMOTE_WATCHER_PID 2>/dev/null
end
```

Note: Fish's subprocess isolation makes background watchers trickier. Alternative approach: check socket in fish_prompt and reconnect there (still fast - just file existence check).

**Disconnect detection - using fish_prompt:**
```fish
function _terminal_remote_prompt_check --on-event fish_prompt
  if test $_TERMINAL_REMOTE_CONNECTED -eq 1 -a -n "$_TERMINAL_REMOTE_BG_PID"
    if not kill -0 $_TERMINAL_REMOTE_BG_PID 2>/dev/null
      set -g _TERMINAL_REMOTE_CONNECTED 0
      echo "Terminal Remote disconnected"
      _terminal_remote_start_watcher
    end
  end
  # Also check for reconnection opportunity
  if test $_TERMINAL_REMOTE_CONNECTED -eq 0 -a -S "$_TERMINAL_REMOTE_SOCKET"
    _terminal_remote_connect
    test $_TERMINAL_REMOTE_CONNECTED -eq 1; and echo "Connected to Terminal Remote"
  end
end
```

**Exit cleanup using fish event:**
```fish
function _terminal_remote_cleanup --on-event fish_exit
  test $_TERMINAL_REMOTE_CONNECTED -eq 1; or return
  test -n "$_TERMINAL_REMOTE_BG_PID"; and kill $_TERMINAL_REMOTE_BG_PID 2>/dev/null
  test -n "$_TERMINAL_REMOTE_WATCHER_PID"; and kill $_TERMINAL_REMOTE_WATCHER_PID 2>/dev/null
end
```

**Important fish-specific notes:**
- Use `%self` for current shell PID
- `set -g` for global variables
- `string replace` for string manipulation
- `--on-event fish_exit` for exit handler
- `--on-variable PWD` for directory change hook
- `--on-event fish_prompt` for connection checking
  </action>
  <verify>
Run: `fish -c 'source shell-integration/init.fish && echo $_TERMINAL_REMOTE_SOCKET'` outputs `/tmp/terminal-remote.sock`

Check chpwd hook: `fish -c 'source shell-integration/init.fish && functions _terminal_remote_chpwd'` shows `--on-variable PWD`

Verify startup message: `rm -f /tmp/terminal-remote.sock && fish -c 'source shell-integration/init.fish'` prints "Terminal Remote not running"
  </verify>
  <done>
init.fish exists with: connection logic, JSON escaping, fish_exit event handler, --on-variable PWD for directory change tracking, fish_prompt for disconnect detection and reconnection, startup message when mac-client not running. Functions load without errors in fish 3.0+.
  </done>
</task>

</tasks>

<verification>
All scripts load without errors in their respective shells:
- `zsh -c 'source shell-integration/init.zsh'` exits 0
- `bash --norc -c 'source shell-integration/init.bash'` exits 0
- `fish -c 'source shell-integration/init.fish'` exits 0

Scripts define required functions:
- Session name function returns "dirname [PID]" format
- JSON escape handles quotes and backslashes
- Connect function is defined
- Directory change hook is registered (chpwd/PROMPT_COMMAND/--on-variable PWD)

Socket path constant is /tmp/terminal-remote.sock in all scripts.

When mac-client not running, startup prints "Terminal Remote not running".
</verification>

<success_criteria>
1. shell-integration/ directory contains init.zsh, init.bash, init.fish
2. Each script loads without errors in its shell
3. Each script has: socket path constant, session name function, JSON escape, connect function, exit cleanup
4. Each script has: directory change hook that sends rename messages (chpwd/PROMPT_COMMAND/--on-variable PWD)
5. Each script prints "Terminal Remote not running" when socket doesn't exist at startup
6. Each script prints "Terminal Remote disconnected" when connection is lost
7. Each script auto-reconnects when mac-client becomes available
8. When socket doesn't exist, scripts complete immediately (no delay)
9. Scripts use background processes for connection (don't block shell)
</success_criteria>

<output>
After completion, create `.planning/phases/06-shell-integration/06-01-SUMMARY.md`
</output>
