---
phase: 07-web-ui-full-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - relay-server/web-ui/src/lib/context/ConnectionContext.tsx
  - relay-server/web-ui/src/lib/context/TabsContext.tsx
  - relay-server/web-ui/src/lib/context/TerminalContext.tsx
autonomous: true

must_haves:
  truths:
    - "Browser connects to /ws endpoint (not /browser)"
    - "Browser sends auth message with session code as first message"
    - "Binary frames are received and routed to correct terminal by session ID"
    - "Sessions appear in tab list when first binary frame arrives"
    - "Input from terminal is sent as binary frames with session ID prefix"
  artifacts:
    - path: "relay-server/web-ui/src/lib/context/ConnectionContext.tsx"
      provides: "WebSocket connection with auth protocol and binary support"
      contains: "ws.binaryType = 'arraybuffer'"
    - path: "relay-server/web-ui/src/lib/context/TabsContext.tsx"
      provides: "Session list derived from binary frames"
      contains: "session_connected"
    - path: "relay-server/web-ui/src/lib/context/TerminalContext.tsx"
      provides: "Binary terminal data routing"
      contains: "writeUtf8"
  key_links:
    - from: "ConnectionContext.tsx"
      to: "binary.ts"
      via: "import decode/encode"
      pattern: "decodeBinaryFrame|encodeBinaryFrame"
    - from: "TerminalContext.tsx"
      to: "ConnectionContext.tsx"
      via: "binary data callback"
      pattern: "onBinaryMessage"
---

<objective>
Update WebSocket connection to use auth protocol and binary frames, enable session tracking from binary data.

Purpose: Connect existing React web UI to Rust relay server with proper protocol alignment.

Output:
- ConnectionContext using auth/auth_success protocol
- Binary WebSocket handling for terminal I/O
- Session list populated from incoming binary frames
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-web-ui-full-pipeline/07-RESEARCH.md
@.planning/phases/07-web-ui-full-pipeline/07-01-SUMMARY.md

Existing context files:
@relay-server/web-ui/src/lib/context/ConnectionContext.tsx
@relay-server/web-ui/src/lib/context/TabsContext.tsx
@relay-server/web-ui/src/lib/context/TerminalContext.tsx

Key changes from v1 to v2 protocol:
- Endpoint: /browser -> /ws
- Auth: join/joined -> auth/auth_success/auth_failed
- Terminal data: JSON terminal_data -> binary frames
- Session ID in each binary frame header (1-byte length prefix)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ConnectionContext for auth protocol and binary WebSocket</name>
  <files>relay-server/web-ui/src/lib/context/ConnectionContext.tsx</files>
  <action>
Refactor ConnectionContext.tsx for the v2 Rust relay protocol:

1. **Change WebSocket endpoint:**
   - Replace `/browser` with `/ws` in relayUrl
   - Derive from window.location for production: `${location.protocol === 'https:' ? 'wss:' : 'ws:'}//${location.host}/ws`
   - Keep env var override for development

2. **Update auth flow:**
   - On WebSocket open, send: `{ "type": "auth", "session_code": code }`
   - Handle `auth_success` -> set connected state
   - Handle `auth_failed` -> set error, disconnect
   - Remove join/joined/rejoin handling (v1 protocol)

3. **Add binary message handling:**
   - Set `ws.binaryType = 'arraybuffer'` after creating WebSocket
   - In message handler, check `event.data instanceof ArrayBuffer`
   - For binary: decode with decodeBinaryFrame, dispatch to binary message handlers
   - For text: parse JSON, handle control messages (auth_success, auth_failed, error)

4. **Add binary message dispatch:**
   - Add `registerBinaryHandler: (handler: (sessionId: string, data: Uint8Array) => void) => () => void`
   - Store handlers in ref, call with decoded session ID and payload
   - Add `sendBinary: (frame: Uint8Array) => void` for sending binary frames

5. **Update send functions:**
   - `sendTerminalInput(sessionId, payload)` -> use encodeBinaryFrame from binary.ts
   - `sendTerminalResize(sessionId, cols, rows)` -> use encodeResizeMessage from binary.ts
   - Remove JSON-based terminal_input and terminal_resize sending

6. **Simplify reconnection:**
   - Remove rejoin logic (v1 feature)
   - Keep reconnecting-websocket for connection resilience
   - On reconnect, re-authenticate with same session code
  </action>
  <verify>
1. Check TypeScript compiles: `cd relay-server/web-ui && pnpm exec tsc --noEmit`
2. Verify WebSocket endpoint is `/ws`
3. Verify binary handling exists: grep for `binaryType` and `ArrayBuffer`
  </verify>
  <done>ConnectionContext connects to /ws, sends auth message, handles binary frames</done>
</task>

<task type="auto">
  <name>Task 2: Update TabsContext for dynamic session tracking</name>
  <files>relay-server/web-ui/src/lib/context/TabsContext.tsx</files>
  <action>
Refactor TabsContext.tsx to track sessions from binary frame headers:

1. **Simplify session model:**
   - Sessions are now shell sessions (not iTerm tabs)
   - Remove tabId concept, use sessionId only
   - Session has: id, name, connected (boolean), lastActivity (timestamp)

2. **Add session from binary data:**
   - Register binary handler with ConnectionContext
   - When binary frame arrives with new sessionId:
     - Add session to list if not exists
     - Update lastActivity timestamp
     - If first session, auto-switch to it (per phase context decision)
   - Use session ID as display name initially (can be updated later)

3. **Handle session_connected/session_disconnected messages:**
   - If relay/mac-client sends explicit session messages (JSON), handle them:
     - `session_connected`: add session with name
     - `session_disconnected`: mark as disconnected, remove after 5 seconds
     - `session_renamed`: update session name
   - These are optional - session list also builds from binary frames

4. **Session disconnect detection:**
   - If no binary data for a session for 30 seconds, consider it inactive
   - Don't remove immediately - user might switch back
   - Per phase context: "show as disconnected briefly (gray out), then remove from list"

5. **Update switchTab to switchSession:**
   - Rename for clarity
   - Clear terminal before switch
   - Send session ID to mac-client if needed

6. **Remove iTerm-specific features:**
   - Remove tab_create, tab_close (shell sessions are managed by user)
   - Remove tabId references
   - Keep createTab/closeTab exports for UI compatibility but make them no-ops for now
  </action>
  <verify>
1. TypeScript compiles: `cd relay-server/web-ui && pnpm exec tsc --noEmit`
2. Verify binary handler registration exists
3. Verify session auto-switch logic for new sessions
  </verify>
  <done>TabsContext tracks sessions from binary frames, auto-switches to new sessions</done>
</task>

<task type="auto">
  <name>Task 3: Update TerminalContext for binary data routing</name>
  <files>relay-server/web-ui/src/lib/context/TerminalContext.tsx</files>
  <action>
Update TerminalContext.tsx for binary terminal data:

1. **Register binary handler with ConnectionContext:**
   - On mount, register a binary message handler
   - When binary data arrives, route to correct terminal by sessionId
   - Use `terminal.writeUtf8(payload)` for efficient binary writes (not .write())

2. **Update terminal write method:**
   - Add `writeToTerminal(sessionId: string, data: Uint8Array)` method
   - Find terminal by sessionId
   - Call `terminal.writeUtf8(data)` for binary data
   - This is more efficient than decoding to string and using .write()

3. **Handle session ID mismatch:**
   - If binary data arrives for unknown sessionId, log warning
   - Don't crash - TabsContext will create the session from the same binary message

4. **Update input/resize callbacks:**
   - Terminal's onInput/onBinary callbacks should use ConnectionContext's sendBinary
   - Use encodeBinaryFrame to wrap input with session ID
   - Use encodeInputMessage for keyboard input
   - Use encodeResizeMessage for resize events

5. **Remove JSON terminal_data handling:**
   - Remove terminal_data and initial_terminal_data message handlers
   - All terminal I/O now uses binary frames
  </action>
  <verify>
1. TypeScript compiles: `cd relay-server/web-ui && pnpm exec tsc --noEmit`
2. Verify writeUtf8 usage for binary writes
3. Verify binary handler registration
  </verify>
  <done>TerminalContext routes binary data to terminals using writeUtf8</done>
</task>

</tasks>

<verification>
1. Full TypeScript check: `cd relay-server/web-ui && pnpm exec tsc --noEmit`
2. Start dev server: `cd relay-server/web-ui && pnpm dev`
3. Open browser console, verify no React errors
4. If relay is running, verify:
   - WebSocket connects to /ws
   - Auth message sent on connect
   - Binary frames received (if mac-client + shell connected)
</verification>

<success_criteria>
- WebSocket connects to /ws endpoint
- Auth protocol (auth/auth_success) works correctly
- Binary frames are decoded and routed to terminals
- Sessions appear in tab list when first binary data arrives
- Terminal input is sent as binary frames with session ID
- No TypeScript or runtime errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-web-ui-full-pipeline/07-02-SUMMARY.md`
</output>
