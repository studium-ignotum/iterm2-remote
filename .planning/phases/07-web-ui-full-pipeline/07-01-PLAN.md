---
phase: 07-web-ui-full-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - relay-server/web-ui/src/lib/protocol/binary.ts
  - relay-server/web-ui/src/shared/protocol.ts
autonomous: true

must_haves:
  truths:
    - "Binary frames can be encoded with session ID prefix"
    - "Binary frames can be decoded to extract session ID and payload"
    - "Auth protocol types match Rust relay expectations"
  artifacts:
    - path: "relay-server/web-ui/src/lib/protocol/binary.ts"
      provides: "Binary frame encode/decode utilities"
      exports: ["encodeBinaryFrame", "decodeBinaryFrame"]
    - path: "relay-server/web-ui/src/shared/protocol.ts"
      provides: "Auth message types"
      contains: "AuthMessage"
  key_links:
    - from: "binary.ts"
      to: "Uint8Array"
      via: "Binary data encoding"
      pattern: "new Uint8Array"
---

<objective>
Create binary frame encoding/decoding utilities and update protocol types for Rust relay compatibility.

Purpose: Enable binary WebSocket communication for efficient terminal I/O, replacing JSON-based terminal_data messages.

Output:
- `src/lib/protocol/binary.ts` with encode/decode functions
- Updated `src/shared/protocol.ts` with auth message types
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-web-ui-full-pipeline/07-RESEARCH.md

Existing protocol file:
@relay-server/web-ui/src/shared/protocol.ts

Binary frame format (from Phase 5-6 decisions):
- 1-byte length prefix for session ID
- Session ID bytes (UTF-8)
- Payload bytes (terminal data)

Rust relay expects:
- Browser first message: `{ "type": "auth", "session_code": "ABC123" }`
- Relay responds: `{ "type": "auth_success" }` or `{ "type": "auth_failed", "reason": "..." }`
- After auth: binary frames for terminal I/O
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create binary frame utilities</name>
  <files>relay-server/web-ui/src/lib/protocol/binary.ts</files>
  <action>
Create new file `src/lib/protocol/binary.ts` with:

1. `encodeBinaryFrame(sessionId: string, payload: Uint8Array): Uint8Array`
   - Create frame: 1 byte session ID length + session ID bytes + payload bytes
   - Use TextEncoder for session ID to bytes conversion
   - Return combined Uint8Array

2. `decodeBinaryFrame(frame: Uint8Array): { sessionId: string; payload: Uint8Array }`
   - Extract session ID length from first byte
   - Extract session ID bytes and decode with TextDecoder
   - Extract remaining bytes as payload
   - Return object with sessionId and payload

3. `encodeResizeMessage(sessionId: string, cols: number, rows: number): Uint8Array`
   - Create resize payload: JSON string `{"type":"resize","cols":N,"rows":N}`
   - Encode with encodeBinaryFrame

4. `encodeInputMessage(sessionId: string, input: string): Uint8Array`
   - Encode input string as UTF-8 bytes
   - Use encodeBinaryFrame for session routing

Add JSDoc comments explaining the binary frame format and usage.
  </action>
  <verify>
Create inline tests or add console.log verification:
```typescript
// Test encode/decode roundtrip
const frame = encodeBinaryFrame("sess-1", new TextEncoder().encode("hello"));
const decoded = decodeBinaryFrame(frame);
console.assert(decoded.sessionId === "sess-1");
console.assert(new TextDecoder().decode(decoded.payload) === "hello");
```
  </verify>
  <done>Binary frame encode/decode functions export correctly and roundtrip works</done>
</task>

<task type="auto">
  <name>Task 2: Update protocol types for auth</name>
  <files>relay-server/web-ui/src/shared/protocol.ts</files>
  <action>
Update `src/shared/protocol.ts` to add auth message types matching Rust relay:

1. Add new message schemas:
```typescript
// Browser -> Relay
export const AuthMessage = z.object({
  type: z.literal('auth'),
  session_code: z.string(),
});
export type AuthMessage = z.infer<typeof AuthMessage>;

// Relay -> Browser
export const AuthSuccessMessage = z.object({
  type: z.literal('auth_success'),
});
export type AuthSuccessMessage = z.infer<typeof AuthSuccessMessage>;

export const AuthFailedMessage = z.object({
  type: z.literal('auth_failed'),
  reason: z.string(),
});
export type AuthFailedMessage = z.infer<typeof AuthFailedMessage>;

// Session events (from mac-client via relay)
export const SessionConnectedMessage = z.object({
  type: z.literal('session_connected'),
  session_id: z.string(),
  name: z.string(),
});
export type SessionConnectedMessage = z.infer<typeof SessionConnectedMessage>;

export const SessionDisconnectedMessage = z.object({
  type: z.literal('session_disconnected'),
  session_id: z.string(),
});
export type SessionDisconnectedMessage = z.infer<typeof SessionDisconnectedMessage>;
```

2. Keep existing JoinMessage/JoinedMessage for backwards compatibility during transition

3. Add auth messages to IncomingMessage and OutgoingMessage unions

4. Export new types
  </action>
  <verify>
TypeScript compilation succeeds:
```bash
cd relay-server/web-ui && pnpm exec tsc --noEmit
```
  </verify>
  <done>Auth message types compile and export correctly, matching Rust relay protocol</done>
</task>

</tasks>

<verification>
1. Run TypeScript check: `cd relay-server/web-ui && pnpm exec tsc --noEmit`
2. Verify binary.ts exports correct functions
3. Verify protocol.ts includes AuthMessage, AuthSuccessMessage, AuthFailedMessage
</verification>

<success_criteria>
- Binary frame encode/decode roundtrip works correctly
- Auth message types match Rust relay's ControlMessage enum
- No TypeScript errors in the web-ui project
</success_criteria>

<output>
After completion, create `.planning/phases/07-web-ui-full-pipeline/07-01-SUMMARY.md`
</output>
