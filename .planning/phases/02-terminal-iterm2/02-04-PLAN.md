---
phase: 02-terminal-iterm2
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - package.json
  - src/lib/components/Terminal.svelte
  - src/lib/stores/terminal.svelte.ts
  - src/lib/iterm-theme.ts
  - src/lib/stores/connection.ts
  - src/routes/+page.svelte
autonomous: true

must_haves:
  truths:
    - "Terminal output streams in real-time in the browser with full escape sequence rendering"
    - "User can type in the browser and keystrokes are sent to Mac client"
    - "Colors, cursor, bold, underline, and other ANSI attributes render correctly"
    - "Terminal resizes responsively with the browser window"
    - "WebGL renderer is used with DOM fallback on context loss"
    - "iTerm2 theme (font, colors, cursor style) is applied when config message received"
  artifacts:
    - path: "src/lib/components/Terminal.svelte"
      provides: "xterm-svelte terminal component with WebGL, fit, clipboard, image addons"
      min_lines: 80
    - path: "src/lib/stores/terminal.svelte.ts"
      provides: "Terminal state management with Svelte 5 runes"
      exports: ["terminalStore"]
    - path: "src/lib/iterm-theme.ts"
      provides: "Converts iTerm2 config message to xterm.js ITerminalOptions"
      exports: ["configToXtermOptions", "defaultTerminalOptions"]
  key_links:
    - from: "src/lib/components/Terminal.svelte"
      to: "src/lib/stores/terminal.svelte.ts"
      via: "reads terminal config and active session from store"
      pattern: "terminalStore"
    - from: "src/lib/components/Terminal.svelte"
      to: "src/lib/stores/connection.ts"
      via: "sends terminal_input messages, receives terminal_data"
      pattern: "send|terminal_input|terminal_data"
    - from: "src/lib/stores/terminal.svelte.ts"
      to: "src/lib/iterm-theme.ts"
      via: "converts config message to xterm options"
      pattern: "configToXtermOptions"
    - from: "src/lib/stores/connection.ts"
      to: "src/lib/components/Terminal.svelte"
      via: "dispatches terminal_data messages to terminal"
      pattern: "terminal_data|onTerminalData"
---

<objective>
Rewrite the browser terminal component using xterm-svelte with WebGL rendering, responsive resize, iTerm2 theme support, and manual WebSocket data binding for the multiplexed connection.

Purpose: This is the primary user-facing component — the terminal in the browser. Without a properly configured xterm.js terminal that receives data from the relay and sends input back, the user sees nothing.

Output: Rewritten Terminal.svelte using xterm-svelte, terminal state store, iTerm2-to-xterm theme converter, and updated connection store to handle terminal_data messages.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-terminal-iterm2/02-RESEARCH.md
@.planning/phases/02-terminal-iterm2/02-CONTEXT.md
@.planning/phases/02-terminal-iterm2/02-01-SUMMARY.md

# Existing files to modify/replace:
@src/lib/components/Terminal.svelte
@src/lib/stores/connection.ts
@src/routes/+page.svelte
@package.json

# Protocol reference:
@src/shared/protocol.ts
@src/shared/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install xterm-svelte and create Terminal.svelte with addons</name>
  <files>
    package.json
    src/lib/components/Terminal.svelte
  </files>
  <action>
1. Update dependencies in package.json:
   - Remove old packages: @xterm/xterm, @xterm/addon-fit (xterm-svelte bundles these)
   - Install: `pnpm add @battlefieldduck/xterm-svelte @xterm/addon-web-fonts @xterm/addon-unicode-graphemes`

   xterm-svelte v2.2.0 bundles: @xterm/xterm@^6.0.0, @xterm/addon-fit, @xterm/addon-webgl, @xterm/addon-image, @xterm/addon-clipboard, @xterm/addon-web-links, @xterm/addon-serialize, @xterm/addon-search, @xterm/addon-unicode11

2. Rewrite src/lib/components/Terminal.svelte using xterm-svelte:

   ```svelte
   <script lang="ts">
     import { Xterm, XtermAddon } from '@battlefieldduck/xterm-svelte';
     import type { Terminal, ITerminalOptions } from '@battlefieldduck/xterm-svelte';
     import { onDestroy } from 'svelte';
     import { terminalStore } from '$lib/stores/terminal.svelte';

     // Props
     let { sessionId, onInput, onResize, options } = $props<{
       sessionId: string;
       onInput: (data: string) => void;
       onResize: (cols: number, rows: number) => void;
       options: ITerminalOptions;
     }>();

     let terminal = $state<Terminal>();
     let fitAddon: any = null;
     let webglAddon: any = null;
     let resizeTimeout: ReturnType<typeof setTimeout>;

     async function onLoad() {
       if (!terminal) return;

       // Load WebGL renderer (GPU-accelerated, with DOM fallback)
       try {
         const { WebglAddon } = await XtermAddon.WebglAddon();
         webglAddon = new WebglAddon();
         webglAddon.onContextLoss(() => {
           console.warn('[Terminal] WebGL context lost, falling back to DOM renderer');
           webglAddon?.dispose();
           webglAddon = null;
         });
         terminal.loadAddon(webglAddon);
       } catch {
         console.warn('[Terminal] WebGL not available, using DOM renderer');
       }

       // Load FitAddon for responsive resize
       const { FitAddon } = await XtermAddon.FitAddon();
       fitAddon = new FitAddon();
       terminal.loadAddon(fitAddon);

       // Load ClipboardAddon for OSC 52 clipboard access
       try {
         const { ClipboardAddon } = await XtermAddon.ClipboardAddon();
         terminal.loadAddon(new ClipboardAddon());
       } catch (e) {
         console.warn('[Terminal] Clipboard addon not available:', e);
       }

       // Load ImageAddon for sixel and iTerm2 inline images
       try {
         const { ImageAddon } = await XtermAddon.ImageAddon();
         terminal.loadAddon(new ImageAddon());
       } catch (e) {
         console.warn('[Terminal] Image addon not available:', e);
       }

       // Load WebLinksAddon for clickable URLs
       try {
         const { WebLinksAddon } = await XtermAddon.WebLinksAddon();
         terminal.loadAddon(new WebLinksAddon());
       } catch (e) {
         console.warn('[Terminal] WebLinks addon not available:', e);
       }

       // Responsive resize using ResizeObserver with debounce
       const container = terminal.element?.parentElement;
       if (container) {
         const observer = new ResizeObserver(() => {
           clearTimeout(resizeTimeout);
           resizeTimeout = setTimeout(() => {
             if (container.clientWidth > 0 && container.clientHeight > 0) {
               fitAddon?.fit();
             }
           }, 100); // 100ms debounce per research guidance
         });
         observer.observe(container);
       }

       // Propagate resize to backend PTY
       terminal.onResize(({ cols, rows }) => {
         onResize(cols, rows);
       });

       // Initial fit after a brief delay (ensures container has dimensions)
       setTimeout(() => fitAddon?.fit(), 50);

       // Register this terminal instance in the store for receiving data
       terminalStore.registerTerminal(sessionId, terminal);
     }

     function onData(data: string) {
       // Send user keystrokes to Mac client via relay
       onInput(data);
     }

     function onBinary(data: string) {
       // Binary data (legacy mouse reports) — also send as input
       onInput(data);
     }

     onDestroy(() => {
       clearTimeout(resizeTimeout);
       terminalStore.unregisterTerminal(sessionId);
       webglAddon?.dispose();
       terminal?.dispose();
     });
   </script>

   <div class="terminal-container">
     <Xterm
       bind:terminal
       options={options}
       {onLoad}
       {onData}
       {onBinary}
     />
   </div>

   <style>
     .terminal-container {
       width: 100%;
       height: 100%;
       overflow: hidden;
     }

     .terminal-container :global(.xterm) {
       height: 100%;
       padding: 4px;
     }
   </style>
   ```

   IMPORTANT anti-patterns to avoid (from research):
   - Do NOT use addon-attach (our WebSocket is multiplexed, not 1:1)
   - Do NOT create terminal before container is sized
   - Always debounce fitAddon.fit() calls (100ms)
   - Guard against zero dimensions in resize
   - Dispose terminal on component destroy to prevent memory leaks
   - Use try/catch for each addon load (graceful degradation)
  </action>
  <verify>
    `cd /Users/nat/Desktop/claude-code-remote && pnpm check` passes TypeScript checking.
    Verify @battlefieldduck/xterm-svelte is in package.json dependencies.
    Verify old @xterm/xterm and @xterm/addon-fit are removed.
  </verify>
  <done>
    Terminal.svelte uses xterm-svelte with WebGL renderer, FitAddon for responsive resize, ClipboardAddon, ImageAddon, WebLinksAddon. Handles data/binary input events, resize propagation, and proper cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create terminal store, iTerm2 theme converter, and wire to WebSocket</name>
  <files>
    src/lib/stores/terminal.svelte.ts
    src/lib/iterm-theme.ts
    src/lib/stores/connection.ts
    src/routes/+page.svelte
  </files>
  <action>
1. Create src/lib/iterm-theme.ts — converts iTerm2 config to xterm.js options:

   ```typescript
   import type { ITerminalOptions, ITheme } from '@battlefieldduck/xterm-svelte';

   interface ConfigMessage {
     font: string;
     fontSize: number;
     cursorStyle: 'block' | 'underline' | 'bar';
     cursorBlink: boolean;
     scrollback: number;
     theme: Record<string, string>;
   }

   export function configToXtermOptions(config: ConfigMessage): ITerminalOptions {
     const theme: ITheme = {
       foreground: config.theme.foreground,
       background: config.theme.background,
       cursor: config.theme.cursor,
       selectionBackground: config.theme.selectionBackground,
       black: config.theme.black,
       red: config.theme.red,
       green: config.theme.green,
       yellow: config.theme.yellow,
       blue: config.theme.blue,
       magenta: config.theme.magenta,
       cyan: config.theme.cyan,
       white: config.theme.white,
       brightBlack: config.theme.brightBlack,
       brightRed: config.theme.brightRed,
       brightGreen: config.theme.brightGreen,
       brightYellow: config.theme.brightYellow,
       brightBlue: config.theme.brightBlue,
       brightMagenta: config.theme.brightMagenta,
       brightCyan: config.theme.brightCyan,
       brightWhite: config.theme.brightWhite,
     };

     return {
       fontFamily: config.font || 'Menlo, Monaco, "Courier New", monospace',
       fontSize: config.fontSize || 13,
       cursorStyle: config.cursorStyle || 'block',
       cursorBlink: config.cursorBlink ?? true,
       scrollback: config.scrollback || 10000,
       theme,
       allowTransparency: false,
       macOptionIsMeta: false,     // Keep Cmd+C/V for copy/paste
       customGlyphs: true,         // Better box drawing characters
       drawBoldTextInBrightColors: true,
       scrollOnUserInput: true,
     };
   }

   export const defaultTerminalOptions: ITerminalOptions = {
     fontFamily: 'Menlo, Monaco, "Courier New", monospace',
     fontSize: 13,
     cursorStyle: 'block',
     cursorBlink: true,
     scrollback: 10000,
     theme: {
       background: '#1e1e1e',
       foreground: '#d4d4d4',
       cursor: '#ffffff',
       selectionBackground: '#264f78',
       black: '#000000',
       red: '#cd3131',
       green: '#0dbc79',
       yellow: '#e5e510',
       blue: '#2472c8',
       magenta: '#bc3fbc',
       cyan: '#11a8cd',
       white: '#e5e5e5',
       brightBlack: '#666666',
       brightRed: '#f14c4c',
       brightGreen: '#23d18b',
       brightYellow: '#f5f543',
       brightBlue: '#3b8eea',
       brightMagenta: '#d670d6',
       brightCyan: '#29b8db',
       brightWhite: '#e5e5e5',
     },
     allowTransparency: false,
     macOptionIsMeta: false,
     customGlyphs: true,
     drawBoldTextInBrightColors: true,
     scrollOnUserInput: true,
   };
   ```

2. Create src/lib/stores/terminal.svelte.ts — terminal state with Svelte 5 runes:

   ```typescript
   import type { Terminal, ITerminalOptions } from '@battlefieldduck/xterm-svelte';
   import { configToXtermOptions, defaultTerminalOptions } from '$lib/iterm-theme';

   // Active session being displayed
   let activeSessionId = $state<string | null>(null);
   let terminalOptions = $state<ITerminalOptions>(defaultTerminalOptions);

   // Map of sessionId -> Terminal instance (for writing data to correct terminal)
   const terminals = new Map<string, Terminal>();

   export const terminalStore = {
     get activeSessionId() { return activeSessionId; },
     get options() { return terminalOptions; },

     setActiveSession(sessionId: string) {
       activeSessionId = sessionId;
     },

     applyConfig(config: any) {
       terminalOptions = configToXtermOptions(config);
     },

     registerTerminal(sessionId: string, terminal: Terminal) {
       terminals.set(sessionId, terminal);
     },

     unregisterTerminal(sessionId: string) {
       terminals.delete(sessionId);
     },

     /**
      * Write terminal data to the correct terminal instance.
      * Called when terminal_data message received from relay.
      */
     writeData(sessionId: string, payload: string) {
       const terminal = terminals.get(sessionId);
       if (terminal) {
         terminal.write(payload);
       }
     },
   };
   ```

3. Update src/lib/stores/connection.ts:
   - Import terminalStore: `import { terminalStore } from './terminal.svelte';`
   - In handleMessage, add cases for new message types:
     ```typescript
     case 'terminal_data': {
       // Route terminal output to correct terminal instance
       terminalStore.writeData(data.sessionId, data.payload);
       break;
     }
     case 'config': {
       // Apply iTerm2 configuration
       terminalStore.applyConfig(data);
       break;
     }
     case 'tab_list':
     case 'tab_switch':
     case 'tab_created':
     case 'tab_closed': {
       // Tab messages will be handled in Plan 02-05
       // For now, log them
       console.log('[Connection] Tab message:', data.type, data);
       break;
     }
     ```
   - Update the send() function to accept any message type (not just DataMessage):
     ```typescript
     export function sendMessage(message: object): void {
       if (state === 'connected' && ws && ws.readyState === WebSocket.OPEN) {
         ws.send(JSON.stringify(message));
       }
     }
     ```
   - Keep the existing send() function for backward compat, but also add sendMessage for typed messages.

4. Update src/routes/+page.svelte:
   - Import Terminal component and terminalStore
   - Replace any existing terminal placeholder with the new Terminal component
   - Wire onInput to send terminal_input messages via sendMessage:
     ```typescript
     function handleInput(data: string) {
       const sessionId = terminalStore.activeSessionId;
       if (sessionId) {
         sendMessage({
           type: 'terminal_input',
           sessionId,
           payload: data,
         });
       }
     }

     function handleResize(cols: number, rows: number) {
       const sessionId = terminalStore.activeSessionId;
       if (sessionId) {
         sendMessage({
           type: 'terminal_resize',
           sessionId,
           cols,
           rows,
         });
       }
     }
     ```
   - Render Terminal conditionally when connected and activeSessionId exists:
     ```svelte
     {#if connectionStore.isConnected && terminalStore.activeSessionId}
       <Terminal
         sessionId={terminalStore.activeSessionId}
         options={terminalStore.options}
         onInput={handleInput}
         onResize={handleResize}
       />
     {:else if connectionStore.isConnected}
       <p>Waiting for terminal session...</p>
     {/if}
     ```
  </action>
  <verify>
    `cd /Users/nat/Desktop/claude-code-remote && pnpm check` passes.
    Verify terminal.svelte.ts exports terminalStore with activeSessionId, options, writeData, applyConfig, registerTerminal, unregisterTerminal.
    Verify connection.ts handles terminal_data and config messages.
    Verify +page.svelte renders Terminal component with correct props.
  </verify>
  <done>
    Terminal store manages active session and xterm options. iTerm2 theme converter translates config messages. Connection store routes terminal_data to correct terminal. Main page renders terminal with input/resize handlers.
  </done>
</task>

</tasks>

<verification>
1. `pnpm check` passes with no TypeScript errors
2. xterm-svelte is installed and old xterm packages removed
3. Terminal.svelte uses xterm-svelte with WebGL, FitAddon, ClipboardAddon, ImageAddon
4. Terminal data flows: relay → connection store → terminalStore.writeData → terminal.write()
5. Input flows: terminal.onData → onInput prop → sendMessage({ type: 'terminal_input' })
6. Resize flows: ResizeObserver → FitAddon.fit → terminal.onResize → sendMessage({ type: 'terminal_resize' })
7. Config message updates xterm.js options via terminalStore.applyConfig
8. Default theme provides reasonable fallback before iTerm2 config arrives
</verification>

<success_criteria>
- Terminal renders in browser with GPU-accelerated WebGL (DOM fallback works)
- Terminal output displays correctly with colors, cursor, bold, underline
- User can type and keystrokes are sent as terminal_input messages
- Terminal resizes responsively (100ms debounce, min dimension guard)
- iTerm2 config (font, colors, cursor) applies when received
- No memory leaks on terminal component unmount (dispose called)
</success_criteria>

<output>
After completion, create `.planning/phases/02-terminal-iterm2/02-04-SUMMARY.md`
</output>
