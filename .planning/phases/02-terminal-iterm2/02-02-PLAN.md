---
phase: 02-terminal-iterm2
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - mac-client/iterm-bridge.py
  - mac-client/coprocess-bridge.sh
  - mac-client/requirements.txt
autonomous: true

must_haves:
  truths:
    - "Python bridge discovers all existing iTerm2 sessions on startup"
    - "Coprocess captures raw PTY bytes from each iTerm2 session"
    - "Python bridge monitors tab focus changes and layout changes in real-time"
    - "Python bridge reads iTerm2 profile configuration (font, colors, cursor, scrollback)"
    - "Python bridge communicates with Node.js Mac client via Unix domain socket"
    - "New iTerm2 sessions automatically get coprocesses attached"
  artifacts:
    - path: "mac-client/iterm-bridge.py"
      provides: "iTerm2 Python API bridge for session monitoring, coprocess management, tab control, config reading"
      min_lines: 150
    - path: "mac-client/coprocess-bridge.sh"
      provides: "Shell script run as iTerm2 coprocess, pipes PTY stdin/stdout to Unix socket"
      min_lines: 15
    - path: "mac-client/requirements.txt"
      provides: "Python dependencies for iTerm2 bridge"
      contains: "iterm2"
  key_links:
    - from: "mac-client/iterm-bridge.py"
      to: "mac-client/coprocess-bridge.sh"
      via: "async_run_coprocess launches shell script per session"
      pattern: "async_run_coprocess"
    - from: "mac-client/coprocess-bridge.sh"
      to: "Unix domain socket"
      via: "socat or netcat connects stdin/stdout to socket"
      pattern: "socat|UNIX-CONNECT"
    - from: "mac-client/iterm-bridge.py"
      to: "iTerm2 Python API"
      via: "iterm2 library imports"
      pattern: "import iterm2"
---

<objective>
Create the iTerm2 Python bridge that uses the iTerm2 Python API to discover sessions, attach coprocesses for raw PTY capture, monitor tab changes, and read profile configuration. Includes the coprocess shell script that bridges PTY I/O to a Unix domain socket.

Purpose: This is the critical link between iTerm2 and the rest of the system. Without it, there's no way to capture terminal output from existing iTerm2 sessions or manage tabs programmatically.

Output: A Python script (iterm-bridge.py) that runs as a subprocess of the Mac client, communicating via Unix domain socket, and a shell script (coprocess-bridge.sh) that iTerm2 runs as a coprocess per session.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-terminal-iterm2/02-RESEARCH.md
@.planning/phases/02-terminal-iterm2/02-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create iTerm2 Python bridge with session management and config reading</name>
  <files>
    mac-client/iterm-bridge.py
    mac-client/requirements.txt
  </files>
  <action>
1. Create mac-client/requirements.txt:
   ```
   iterm2>=2.7
   ```
   Note: pyobjc is NOT required — the iterm2 Python package handles the protobuf/WebSocket connection to iTerm2 directly.

2. Create mac-client/iterm-bridge.py — a standalone Python script that uses the iTerm2 Python API. It will be launched as a subprocess by the Node.js Mac client.

   Communication protocol: JSON lines over Unix domain socket. The script creates a Unix socket server, and the Node.js Mac client connects to it. Each line is a JSON message.

   Message types FROM Python → Node.js:
   - {"type": "sessions", "sessions": [{"session_id": "...", "tab_id": "...", "title": "...", "is_active": true}]}
   - {"type": "terminal_data", "session_id": "...", "data": "base64-encoded-bytes"}
   - {"type": "tab_switched", "tab_id": "..."}
   - {"type": "tabs_changed", "tabs": [...]}  (same format as sessions)
   - {"type": "config", "font": "...", "fontSize": 13, "cursorStyle": "block", "cursorBlink": true, "scrollback": 10000, "theme": {...}}
   - {"type": "ready"}  (sent after initial setup complete)
   - {"type": "error", "message": "..."}

   Message types FROM Node.js → Python:
   - {"type": "terminal_input", "session_id": "...", "data": "base64-encoded-bytes"}
   - {"type": "terminal_resize", "session_id": "...", "cols": 80, "rows": 24}
   - {"type": "tab_switch", "tab_id": "..."}
   - {"type": "tab_create"}
   - {"type": "tab_close", "tab_id": "..."}

   Implementation structure:
   ```python
   import iterm2
   import asyncio
   import json
   import os
   import sys
   import base64

   SOCKET_PATH = sys.argv[1] if len(sys.argv) > 1 else "/tmp/iterm-bridge.sock"
   COPROCESS_SCRIPT = os.path.join(os.path.dirname(os.path.abspath(__file__)), "coprocess-bridge.sh")

   class ITerm2Bridge:
       def __init__(self):
           self.connection = None
           self.app = None
           self.client_writer = None
           self.session_map = {}  # session_id -> session object
           self.coprocess_sockets = {}  # session_id -> (reader, writer) for coprocess data

       async def main(self, connection):
           self.connection = connection
           self.app = await iterm2.async_get_app(connection)

           # Start Unix socket server
           server = await asyncio.start_unix_server(
               self.handle_client, SOCKET_PATH
           )

           # Wait for Node.js client to connect
           # Then enumerate sessions, start coprocesses, send config
           await server.serve_forever()

       async def handle_client(self, reader, writer):
           self.client_writer = writer
           try:
               # Send initial session list
               await self.enumerate_and_send_sessions()
               # Send iTerm2 config
               await self.send_config()
               # Start monitors
               await asyncio.gather(
                   self.monitor_focus(),
                   self.monitor_layout(),
                   self.monitor_new_sessions(),
                   self.read_client_commands(reader),
               )
           except asyncio.CancelledError:
               pass
           finally:
               writer.close()

       async def enumerate_and_send_sessions(self):
           """Discover all iTerm2 sessions, start coprocesses, send list to client."""
           # ... iterate app.terminal_windows > tabs > sessions
           # For each session: store in session_map, start coprocess
           # Send {"type": "sessions", ...} then {"type": "ready"}

       async def start_coprocess(self, session):
           """Start coprocess-bridge.sh for a session."""
           session_id = session.session_id
           # Each coprocess gets its own socket path for data
           data_socket_path = f"/tmp/iterm-coprocess-{session_id.replace(':', '-')}.sock"
           cmd = f"{COPROCESS_SCRIPT} {session_id} {data_socket_path}"
           # Start Unix socket server for this coprocess's data
           coprocess_server = await asyncio.start_unix_server(
               lambda r, w: self.handle_coprocess_data(session_id, r, w),
               data_socket_path
           )
           success = await session.async_run_coprocess(cmd)
           if not success:
               # Coprocess already running or failed
               os.unlink(data_socket_path)

       async def handle_coprocess_data(self, session_id, reader, writer):
           """Receive PTY output from coprocess, forward to Node.js client."""
           self.coprocess_sockets[session_id] = (reader, writer)
           try:
               while True:
                   data = await reader.read(65536)
                   if not data:
                       break
                   # Forward to Node.js client as base64
                   await self.send_to_client({
                       "type": "terminal_data",
                       "session_id": session_id,
                       "data": base64.b64encode(data).decode('ascii')
                   })
           except asyncio.CancelledError:
               pass

       async def monitor_focus(self):
           """Watch for tab focus changes using FocusMonitor."""
           async with iterm2.FocusMonitor(self.connection) as monitor:
               while True:
                   update = await monitor.async_get_next_update()
                   if update.selected_tab_changed:
                       await self.send_to_client({
                           "type": "tab_switched",
                           "tab_id": update.selected_tab_changed.tab_id
                       })

       async def monitor_layout(self):
           """Watch for tab creation/deletion using LayoutChangeMonitor."""
           async with iterm2.LayoutChangeMonitor(self.connection) as monitor:
               while True:
                   await monitor.async_get()
                   self.app = await iterm2.async_get_app(self.connection)
                   await self.enumerate_and_send_sessions()

       async def monitor_new_sessions(self):
           """Watch for new sessions and attach coprocesses."""
           async with iterm2.NewSessionMonitor(self.connection) as monitor:
               while True:
                   session_id = await monitor.async_get()
                   session = self.app.get_session_by_id(session_id)
                   if session:
                       await self.start_coprocess(session)

       async def read_client_commands(self, reader):
           """Read commands from Node.js client."""
           buffer = b""
           while True:
               data = await reader.read(65536)
               if not data:
                   break
               buffer += data
               while b"\n" in buffer:
                   line, buffer = buffer.split(b"\n", 1)
                   msg = json.loads(line)
                   await self.handle_command(msg)

       async def handle_command(self, msg):
           """Handle commands from Node.js client."""
           cmd_type = msg.get("type")
           if cmd_type == "terminal_input":
               # Write to coprocess stdout (becomes iTerm2 keyboard input)
               session_id = msg["session_id"]
               data = base64.b64decode(msg["data"])
               if session_id in self.coprocess_sockets:
                   _, writer = self.coprocess_sockets[session_id]
                   writer.write(data)
                   await writer.drain()
           elif cmd_type == "terminal_resize":
               # Use iTerm2 API to resize session
               session = self.app.get_session_by_id(msg["session_id"])
               if session:
                   # Note: iTerm2 handles resize via the session size
                   pass  # Resize is handled by the coprocess/PTY automatically
           elif cmd_type == "tab_switch":
               await self.switch_tab(msg["tab_id"])
           elif cmd_type == "tab_create":
               await self.create_tab()
           elif cmd_type == "tab_close":
               await self.close_tab(msg["tab_id"])

       async def switch_tab(self, tab_id):
           for window in self.app.terminal_windows:
               for tab in window.tabs:
                   if tab.tab_id == tab_id:
                       await tab.async_select()
                       return

       async def create_tab(self):
           window = self.app.current_terminal_window
           if window:
               await window.async_create_tab()

       async def close_tab(self, tab_id):
           for window in self.app.terminal_windows:
               for tab in window.tabs:
                   if tab.tab_id == tab_id:
                       await tab.async_close()
                       return

       async def send_config(self):
           """Read iTerm2 profile and send config to client."""
           # Get active session's profile
           session = self.app.current_terminal_window.current_tab.current_session
           profile = await session.async_get_profile()
           config = {
               "type": "config",
               "font": profile.normal_font,
               "cursorType": str(profile.cursor_type),
               "cursorBlink": profile.blinking_cursor,
               "scrollback": profile.scrollback_lines if not profile.unlimited_scrollback else 100000,
               "foreground": self.color_to_hex(profile.foreground_color),
               "background": self.color_to_hex(profile.background_color),
               "cursor": self.color_to_hex(profile.cursor_color),
               "selectionColor": self.color_to_hex(profile.selection_color),
               "ansiColors": [
                   self.color_to_hex(getattr(profile, f"ansi_{i}_color"))
                   for i in range(16)
               ]
           }
           await self.send_to_client(config)

       def color_to_hex(self, color):
           r = int(color.red * 255)
           g = int(color.green * 255)
           b = int(color.blue * 255)
           return f"#{r:02x}{g:02x}{b:02x}"

       async def send_to_client(self, msg):
           if self.client_writer:
               line = json.dumps(msg) + "\n"
               self.client_writer.write(line.encode('utf-8'))
               await self.client_writer.drain()

   bridge = ITerm2Bridge()
   iterm2.run_until_complete(bridge.main)
   ```

   IMPORTANT details:
   - Use base64 encoding for terminal data (raw bytes may contain non-UTF-8)
   - JSON lines protocol (one JSON object per line, newline-delimited) for IPC
   - Each coprocess gets its own Unix socket for data flow (avoids multiplexing complexity)
   - The main socket is for control messages (tab switch, create, close, config)
   - Clean up socket files on exit (atexit handler or try/finally)
   - Handle iTerm2 connection failures gracefully (print error, exit with non-zero code)
   - The script path is passed as argv[1] for the main socket path

3. Add proper cleanup: remove socket files on exit, handle SIGTERM gracefully.
  </action>
  <verify>
    Verify Python syntax: `python3 -c "import ast; ast.parse(open('mac-client/iterm-bridge.py').read())"` passes.
    Verify requirements.txt exists with iterm2 dependency.
    Note: Full runtime testing requires iTerm2 with Python API enabled — this will be verified during integration (Plan 02-03).
  </verify>
  <done>
    Python bridge script handles session discovery, coprocess management, tab monitoring (focus + layout + new sessions), profile config reading, and bidirectional command handling. Uses JSON lines over Unix domain socket for IPC with Node.js.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create coprocess bridge shell script</name>
  <files>
    mac-client/coprocess-bridge.sh
  </files>
  <action>
Create mac-client/coprocess-bridge.sh — a shell script that iTerm2 runs as a coprocess for each session.

How iTerm2 coprocesses work:
- iTerm2 starts the script as a subprocess
- The script's STDIN receives raw PTY output (byte-for-byte terminal data including escape sequences)
- The script's STDOUT is treated as keyboard input by iTerm2
- This gives us bidirectional terminal I/O access

The script connects its stdin/stdout to a Unix domain socket so the Python bridge can relay the data:

```bash
#!/bin/bash
# coprocess-bridge.sh - Run as iTerm2 coprocess per session
# Connects terminal I/O to a Unix domain socket for the Python bridge
#
# Usage: coprocess-bridge.sh <session_id> <socket_path>
#
# stdin  = raw PTY output (terminal data from the shell)
# stdout = treated as keyboard input by iTerm2

SESSION_ID="$1"
SOCKET_PATH="$2"

if [ -z "$SESSION_ID" ] || [ -z "$SOCKET_PATH" ]; then
    echo "Usage: $0 <session_id> <socket_path>" >&2
    exit 1
fi

# Wait briefly for the Python bridge to set up the socket server
sleep 0.1

# Use socat to bidirectionally connect stdin/stdout to the Unix socket
# - stdin (PTY output) → socket (Python bridge receives terminal data)
# - socket (Python bridge sends input) → stdout (becomes keyboard input)
#
# If socat is not available, fall back to a simple cat-based approach
if command -v socat &>/dev/null; then
    exec socat - "UNIX-CONNECT:${SOCKET_PATH}"
else
    # Fallback: use a background reader + foreground writer with nc
    # This is less reliable but works without socat
    if command -v nc &>/dev/null; then
        # Create a named pipe for bidirectional communication
        FIFO="/tmp/iterm-coprocess-fifo-$$"
        mkfifo "$FIFO" 2>/dev/null

        # Background: read from socket, write to stdout
        nc -U "$SOCKET_PATH" < "$FIFO" &
        NC_PID=$!

        # Foreground: read from stdin, write to socket via fifo
        cat > "$FIFO"

        # Cleanup
        kill $NC_PID 2>/dev/null
        rm -f "$FIFO"
    else
        echo "Error: socat or nc required for coprocess bridge" >&2
        exit 1
    fi
fi
```

Make the script executable: `chmod +x mac-client/coprocess-bridge.sh`

Key design decisions:
- socat is preferred (bidirectional, clean, handles buffering well)
- nc fallback for systems without socat (less reliable)
- Brief sleep before connecting gives the Python bridge time to set up the listening socket
- The script is intentionally simple — all intelligence is in the Python bridge
- The script exits when the socket closes (which the Python bridge controls)
  </action>
  <verify>
    `bash -n mac-client/coprocess-bridge.sh` passes (syntax check).
    `ls -la mac-client/coprocess-bridge.sh` shows executable permission.
    Verify socat is available on macOS: `which socat` (if not, note that `brew install socat` is needed).
  </verify>
  <done>
    Coprocess bridge script exists, is executable, connects stdin/stdout to Unix domain socket using socat (with nc fallback). Ready to be launched by the Python bridge via async_run_coprocess().
  </done>
</task>

</tasks>

<verification>
1. Python bridge script parses without syntax errors
2. requirements.txt lists iterm2 dependency
3. Coprocess bridge script passes bash syntax check and is executable
4. Python bridge handles: session enumeration, coprocess start, focus/layout/new session monitoring, config reading, tab switch/create/close commands
5. IPC protocol: JSON lines over Unix domain socket, base64 for terminal data
6. Clean socket file handling (cleanup on exit)
</verification>

<success_criteria>
- Python bridge discovers iTerm2 sessions and attaches coprocesses
- Coprocess script bridges PTY I/O to Unix socket
- Tab monitoring detects focus changes and layout changes
- Profile config (font, colors, cursor) can be read and sent
- All commands (tab switch, create, close, terminal input) are handled
- IPC uses JSON lines with base64-encoded terminal data
</success_criteria>

<output>
After completion, create `.planning/phases/02-terminal-iterm2/02-02-SUMMARY.md`
</output>
