---
phase: 02-terminal-iterm2
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - mac-client/src/iterm-bridge.ts
  - mac-client/src/session-manager.ts
  - mac-client/src/connection.ts
  - mac-client/src/index.ts
  - mac-client/package.json
autonomous: true

must_haves:
  truths:
    - "Mac client launches Python bridge as subprocess and communicates via Unix socket"
    - "Terminal output from iTerm2 coprocesses is forwarded to relay as terminal_data messages"
    - "Browser keyboard input received from relay is forwarded to iTerm2 via Python bridge"
    - "Tab list, tab switches, and config are sent to relay when received from Python bridge"
    - "Mac client handles Python bridge crashes by restarting it"
  artifacts:
    - path: "mac-client/src/iterm-bridge.ts"
      provides: "Node.js manager for Python subprocess + Unix socket IPC"
      exports: ["ITerm2Bridge"]
    - path: "mac-client/src/session-manager.ts"
      provides: "Maps iTerm2 sessions to WebSocket protocol messages, routes terminal I/O"
      exports: ["SessionManager"]
  key_links:
    - from: "mac-client/src/iterm-bridge.ts"
      to: "mac-client/iterm-bridge.py"
      via: "child_process.spawn launches Python script"
      pattern: "spawn.*python3.*iterm-bridge"
    - from: "mac-client/src/session-manager.ts"
      to: "mac-client/src/iterm-bridge.ts"
      via: "receives events from bridge, translates to protocol messages"
      pattern: "ITerm2Bridge|bridge\\.on"
    - from: "mac-client/src/session-manager.ts"
      to: "src/shared/protocol.ts"
      via: "constructs terminal_data, tab_list, config messages"
      pattern: "terminal_data|tab_list|config"
    - from: "mac-client/src/index.ts"
      to: "mac-client/src/session-manager.ts"
      via: "integrates session manager with connection manager"
      pattern: "SessionManager"
---

<objective>
Create the Node.js integration layer in the Mac client that manages the iTerm2 Python bridge subprocess, translates IPC messages to/from WebSocket protocol format, and routes terminal I/O between iTerm2 and the relay server.

Purpose: This connects the iTerm2 Python bridge (Plan 02-02) to the WebSocket relay (Plan 02-01). Without this, terminal data from iTerm2 can't reach the browser and browser input can't reach iTerm2.

Output: iterm-bridge.ts (subprocess + IPC manager), session-manager.ts (protocol translation + routing), updated connection.ts and index.ts for integration.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-terminal-iterm2/02-RESEARCH.md
@.planning/phases/02-terminal-iterm2/02-01-SUMMARY.md
@.planning/phases/02-terminal-iterm2/02-02-SUMMARY.md

# Existing files to modify:
@mac-client/src/connection.ts
@mac-client/src/index.ts
@mac-client/package.json

# Protocol reference:
@src/shared/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create iterm-bridge.ts — Python subprocess and Unix socket IPC manager</name>
  <files>
    mac-client/src/iterm-bridge.ts
    mac-client/package.json
  </files>
  <action>
1. Install pip dependency on Mac (add note in output, not a npm dep):
   The Python bridge needs iterm2 pip package. The Node.js code should check if it's installed and print instructions if not.

2. Create mac-client/src/iterm-bridge.ts:

   This module manages the Python subprocess and Unix domain socket communication.

   ```typescript
   import { spawn, type ChildProcess } from 'child_process';
   import { createConnection, type Socket } from 'net';
   import { EventEmitter } from 'events';
   import * as path from 'path';
   import * as fs from 'fs';

   const SOCKET_PATH = '/tmp/iterm-bridge.sock';
   const PYTHON_SCRIPT = path.join(import.meta.dirname, '..', 'iterm-bridge.py');
   const RESTART_DELAY_MS = 3000;
   const MAX_CONNECT_RETRIES = 10;
   const CONNECT_RETRY_DELAY_MS = 500;

   interface BridgeEvents {
     'terminal_data': (sessionId: string, data: Buffer) => void;
     'sessions': (sessions: Array<{session_id: string, tab_id: string, title: string, is_active: boolean}>) => void;
     'tab_switched': (tabId: string) => void;
     'tabs_changed': (tabs: Array<{session_id: string, tab_id: string, title: string, is_active: boolean}>) => void;
     'config': (config: object) => void;
     'ready': () => void;
     'error': (error: Error) => void;
     'exit': (code: number | null) => void;
   }

   export class ITerm2Bridge extends EventEmitter {
     private process: ChildProcess | null = null;
     private socket: Socket | null = null;
     private buffer: string = '';
     private running = false;

     /**
      * Start the Python bridge subprocess and connect via Unix socket.
      */
     async start(): Promise<void> {
       this.running = true;

       // Clean up stale socket file
       try { fs.unlinkSync(SOCKET_PATH); } catch {}

       // Launch Python subprocess
       this.process = spawn('python3', [PYTHON_SCRIPT, SOCKET_PATH], {
         stdio: ['pipe', 'pipe', 'pipe'],
       });

       this.process.stdout?.on('data', (data: Buffer) => {
         console.log('[iTerm2Bridge] Python stdout:', data.toString().trim());
       });

       this.process.stderr?.on('data', (data: Buffer) => {
         console.error('[iTerm2Bridge] Python stderr:', data.toString().trim());
       });

       this.process.on('exit', (code) => {
         console.log(`[iTerm2Bridge] Python process exited with code ${code}`);
         this.socket?.destroy();
         this.socket = null;
         this.process = null;
         this.emit('exit', code);

         // Auto-restart if still supposed to be running
         if (this.running) {
           console.log(`[iTerm2Bridge] Restarting in ${RESTART_DELAY_MS}ms...`);
           setTimeout(() => {
             if (this.running) this.start().catch(console.error);
           }, RESTART_DELAY_MS);
         }
       });

       // Wait for Python to set up the socket, then connect
       await this.connectToSocket();
     }

     /**
      * Connect to the Python bridge's Unix domain socket with retries.
      */
     private async connectToSocket(): Promise<void> {
       for (let i = 0; i < MAX_CONNECT_RETRIES; i++) {
         try {
           await new Promise<void>((resolve, reject) => {
             const socket = createConnection(SOCKET_PATH, () => {
               this.socket = socket;
               this.setupSocketHandlers();
               resolve();
             });
             socket.on('error', reject);
           });
           console.log('[iTerm2Bridge] Connected to Python bridge socket');
           return;
         } catch {
           await new Promise(r => setTimeout(r, CONNECT_RETRY_DELAY_MS));
         }
       }
       throw new Error('Failed to connect to Python bridge socket after retries');
     }

     /**
      * Set up handlers for incoming data from Python bridge.
      */
     private setupSocketHandlers(): void {
       if (!this.socket) return;

       this.socket.on('data', (data: Buffer) => {
         this.buffer += data.toString('utf-8');
         // JSON lines protocol: split on newlines
         let newlineIndex: number;
         while ((newlineIndex = this.buffer.indexOf('\n')) !== -1) {
           const line = this.buffer.slice(0, newlineIndex);
           this.buffer = this.buffer.slice(newlineIndex + 1);
           if (line.trim()) {
             try {
               const msg = JSON.parse(line);
               this.handleMessage(msg);
             } catch (err) {
               console.error('[iTerm2Bridge] Failed to parse message:', line);
             }
           }
         }
       });

       this.socket.on('close', () => {
         console.log('[iTerm2Bridge] Socket closed');
         this.socket = null;
       });

       this.socket.on('error', (err) => {
         console.error('[iTerm2Bridge] Socket error:', err.message);
         this.emit('error', err);
       });
     }

     /**
      * Handle a parsed message from the Python bridge.
      */
     private handleMessage(msg: any): void {
       switch (msg.type) {
         case 'terminal_data':
           // Decode base64 terminal data
           const termData = Buffer.from(msg.data, 'base64');
           this.emit('terminal_data', msg.session_id, termData);
           break;
         case 'sessions':
           this.emit('sessions', msg.sessions);
           break;
         case 'tab_switched':
           this.emit('tab_switched', msg.tab_id);
           break;
         case 'tabs_changed':
           this.emit('tabs_changed', msg.tabs);
           break;
         case 'config':
           this.emit('config', msg);
           break;
         case 'ready':
           this.emit('ready');
           break;
         case 'error':
           this.emit('error', new Error(msg.message));
           break;
         default:
           console.warn('[iTerm2Bridge] Unknown message type:', msg.type);
       }
     }

     /**
      * Send a command to the Python bridge.
      */
     send(msg: object): void {
       if (this.socket && !this.socket.destroyed) {
         const line = JSON.stringify(msg) + '\n';
         this.socket.write(line);
       }
     }

     /**
      * Send terminal input to a specific iTerm2 session.
      */
     sendInput(sessionId: string, data: string): void {
       this.send({
         type: 'terminal_input',
         session_id: sessionId,
         data: Buffer.from(data).toString('base64'),
       });
     }

     /**
      * Send terminal resize to a specific iTerm2 session.
      */
     sendResize(sessionId: string, cols: number, rows: number): void {
       this.send({
         type: 'terminal_resize',
         session_id: sessionId,
         cols,
         rows,
       });
     }

     /**
      * Request tab switch.
      */
     switchTab(tabId: string): void {
       this.send({ type: 'tab_switch', tab_id: tabId });
     }

     /**
      * Request new tab creation.
      */
     createTab(): void {
       this.send({ type: 'tab_create' });
     }

     /**
      * Request tab close.
      */
     closeTab(tabId: string): void {
       this.send({ type: 'tab_close', tab_id: tabId });
     }

     /**
      * Stop the bridge and clean up.
      */
     async stop(): Promise<void> {
       this.running = false;
       this.socket?.destroy();
       this.socket = null;
       if (this.process) {
         this.process.kill('SIGTERM');
         this.process = null;
       }
       // Clean up socket file
       try { fs.unlinkSync(SOCKET_PATH); } catch {}
     }
   }
   ```

3. No new npm dependencies needed. Node.js builtins (child_process, net, events, path, fs) suffice.
  </action>
  <verify>
    `cd /Users/nat/Desktop/claude-code-remote/mac-client && npx tsc --noEmit src/iterm-bridge.ts` compiles.
    Verify ITerm2Bridge class exports start, stop, send, sendInput, sendResize, switchTab, createTab, closeTab methods.
  </verify>
  <done>
    iterm-bridge.ts manages Python subprocess lifecycle, connects via Unix socket, parses JSON lines messages, emits typed events, handles subprocess crashes with auto-restart.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session-manager.ts and update index.ts for terminal I/O routing</name>
  <files>
    mac-client/src/session-manager.ts
    mac-client/src/connection.ts
    mac-client/src/index.ts
  </files>
  <action>
1. Create mac-client/src/session-manager.ts:

   The SessionManager sits between the ITerm2Bridge and the ConnectionManager. It translates between the Python bridge's IPC format and the WebSocket protocol format.

   ```typescript
   import { ITerm2Bridge } from './iterm-bridge.js';

   interface TabInfo {
     tabId: string;
     sessionId: string;
     title: string;
     isActive: boolean;
   }

   interface SessionManagerEvents {
     sendToRelay: (message: string) => void;
   }

   export class SessionManager {
     private bridge: ITerm2Bridge;
     private sendToRelay: (message: string) => void;
     private tabs: TabInfo[] = [];

     constructor(sendToRelay: (message: string) => void) {
       this.sendToRelay = sendToRelay;
       this.bridge = new ITerm2Bridge();
       this.setupBridgeHandlers();
     }

     private setupBridgeHandlers(): void {
       // Terminal output from iTerm2 → relay → browser
       this.bridge.on('terminal_data', (sessionId: string, data: Buffer) => {
         this.sendToRelay(JSON.stringify({
           type: 'terminal_data',
           sessionId,
           payload: data.toString('utf-8'),
         }));
       });

       // Session list → tab_list message
       this.bridge.on('sessions', (sessions) => {
         this.tabs = sessions.map(s => ({
           tabId: s.tab_id,
           sessionId: s.session_id,
           title: s.title || 'Shell',
           isActive: s.is_active,
         }));
         this.sendToRelay(JSON.stringify({
           type: 'tab_list',
           tabs: this.tabs,
         }));
       });

       // Tab focus changed in iTerm2 → notify browser
       this.bridge.on('tab_switched', (tabId: string) => {
         this.sendToRelay(JSON.stringify({
           type: 'tab_switch',
           tabId,
         }));
       });

       // Tabs changed (layout) → re-send full list
       this.bridge.on('tabs_changed', (tabs) => {
         this.tabs = tabs.map((s: any) => ({
           tabId: s.tab_id,
           sessionId: s.session_id,
           title: s.title || 'Shell',
           isActive: s.is_active,
         }));
         this.sendToRelay(JSON.stringify({
           type: 'tab_list',
           tabs: this.tabs,
         }));
       });

       // iTerm2 config → config message
       this.bridge.on('config', (config: any) => {
         // Translate Python bridge config format to protocol ConfigMessage format
         const cursorStyleMap: Record<string, string> = {
           'CURSOR_TYPE_BLOCK': 'block',
           'CURSOR_TYPE_UNDERLINE': 'underline',
           'CURSOR_TYPE_VERTICAL': 'bar',
         };
         const theme: Record<string, string> = {
           foreground: config.foreground,
           background: config.background,
           cursor: config.cursor,
           selectionBackground: config.selectionColor,
         };
         // Map ansi colors to theme keys
         const ansiNames = [
           'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white',
           'brightBlack', 'brightRed', 'brightGreen', 'brightYellow',
           'brightBlue', 'brightMagenta', 'brightCyan', 'brightWhite',
         ];
         if (config.ansiColors) {
           config.ansiColors.forEach((color: string, i: number) => {
             theme[ansiNames[i]] = color;
           });
         }

         // Parse font name and size from iTerm2 format "FontName Size"
         const fontParts = (config.font || '').split(' ');
         const fontSize = parseInt(fontParts.pop() || '13', 10);
         const fontName = fontParts.join(' ') || 'Menlo';

         this.sendToRelay(JSON.stringify({
           type: 'config',
           font: fontName,
           fontSize,
           cursorStyle: cursorStyleMap[config.cursorType] || 'block',
           cursorBlink: config.cursorBlink ?? true,
           scrollback: config.scrollback || 10000,
           theme,
         }));
       });

       this.bridge.on('ready', () => {
         console.log('[SessionManager] iTerm2 bridge ready');
       });

       this.bridge.on('error', (err: Error) => {
         console.error('[SessionManager] Bridge error:', err.message);
       });
     }

     /**
      * Handle a message received from the relay (from browser).
      */
     handleRelayMessage(raw: string): void {
       try {
         const msg = JSON.parse(raw);
         switch (msg.type) {
           case 'terminal_input':
             this.bridge.sendInput(msg.sessionId, msg.payload);
             break;
           case 'terminal_resize':
             this.bridge.sendResize(msg.sessionId, msg.cols, msg.rows);
             break;
           case 'tab_switch':
             this.bridge.switchTab(msg.tabId);
             break;
           case 'tab_create':
             this.bridge.createTab();
             break;
           case 'tab_close':
             this.bridge.closeTab(msg.tabId);
             break;
           default:
             // Ignore other message types (ping, pong, etc.)
             break;
         }
       } catch (err) {
         console.error('[SessionManager] Failed to handle relay message:', err);
       }
     }

     async start(): Promise<void> {
       await this.bridge.start();
     }

     async stop(): Promise<void> {
       await this.bridge.stop();
     }
   }
   ```

2. Update mac-client/src/connection.ts:
   - Add a `handleMessage` callback to ConnectionEvents: `onMessage?: (data: string) => void;`
   - In the `handleMessage` method's default case (or add a new case), call `this.events.onMessage?.(data.toString())` for any message type that's not register/error/pong — these are messages FROM the relay that need to be forwarded to the session manager
   - Add a public `send(data: string)` method that sends raw data via the WebSocket if connected:
     ```typescript
     send(data: string): void {
       if (this.ws?.readyState === WebSocket.OPEN) {
         this.ws.send(data);
       }
     }
     ```

3. Update mac-client/src/index.ts:
   - Import SessionManager
   - After ConnectionManager is created, create a SessionManager:
     ```typescript
     const sessionManager = new SessionManager((message) => {
       connectionManager.send(message);
     });
     ```
   - Wire the ConnectionManager's onMessage to sessionManager:
     ```typescript
     const connectionManager = new ConnectionManager(relayUrl, {
       onCodeReceived: (code) => { /* existing display code */ },
       onMessage: (data) => {
         sessionManager.handleRelayMessage(data);
       },
     });
     ```
   - Start the session manager after connection is established:
     - In onCodeReceived or a new onConnected callback, call `sessionManager.start()`
   - On graceful shutdown, call `sessionManager.stop()` before `connectionManager.disconnect()`
  </action>
  <verify>
    `cd /Users/nat/Desktop/claude-code-remote/mac-client && npx tsc --noEmit` compiles all files without errors.
    Verify SessionManager imports and uses ITerm2Bridge.
    Verify connection.ts has send() method and onMessage callback.
    Verify index.ts creates SessionManager and wires it to ConnectionManager.
  </verify>
  <done>
    SessionManager translates between Python bridge IPC and WebSocket protocol. ConnectionManager has send() and onMessage. index.ts integrates both. Terminal data flows: iTerm2 → Python bridge → Unix socket → iterm-bridge.ts → SessionManager → ConnectionManager → relay → browser. Input flows in reverse.
  </done>
</task>

</tasks>

<verification>
1. All mac-client TypeScript files compile with `npx tsc --noEmit`
2. ITerm2Bridge class manages Python subprocess and Unix socket IPC
3. SessionManager translates IPC messages to protocol format and vice versa
4. ConnectionManager has send() method and onMessage callback
5. index.ts creates and wires SessionManager with ConnectionManager
6. Terminal data flow: iTerm2 coprocess → Python bridge → Node.js → relay
7. Input flow: relay → Node.js → Python bridge → coprocess → iTerm2
</verification>

<success_criteria>
- Mac client starts Python bridge subprocess on connection
- Terminal output from iTerm2 is forwarded as terminal_data messages
- Browser input is forwarded as terminal_input to iTerm2
- Tab operations (switch, create, close) are routed through the bridge
- iTerm2 config is sent to browser on connection
- Python bridge crashes are handled with auto-restart
</success_criteria>

<output>
After completion, create `.planning/phases/02-terminal-iterm2/02-03-SUMMARY.md`
</output>
