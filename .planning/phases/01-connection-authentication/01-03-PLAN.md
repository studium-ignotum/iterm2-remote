---
phase: 01-connection-authentication
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - package.json
  - src/lib/stores/connection.ts
  - src/lib/components/ConnectionStatus.svelte
  - src/routes/login/+page.svelte
  - src/routes/+page.svelte
autonomous: true

must_haves:
  truths:
    - "Browser prompts user for session code"
    - "Valid session code connects successfully"
    - "Invalid session code shows clear error message"
    - "Connection status is visible in the UI"
    - "Browser reconnects automatically after network interruption"
  artifacts:
    - path: "src/lib/stores/connection.ts"
      provides: "WebSocket connection store with state management"
      exports: ["connectionStore", "connect", "disconnect"]
    - path: "src/lib/components/ConnectionStatus.svelte"
      provides: "Visual connection status indicator"
      min_lines: 20
    - path: "src/routes/login/+page.svelte"
      provides: "Session code entry form"
      contains: "input"
  key_links:
    - from: "src/routes/login/+page.svelte"
      to: "src/lib/stores/connection.ts"
      via: "connect function call"
      pattern: "connect\\("
    - from: "src/lib/components/ConnectionStatus.svelte"
      to: "src/lib/stores/connection.ts"
      via: "store subscription"
      pattern: "\\$connectionStore|connectionStore"
    - from: "src/routes/+page.svelte"
      to: "src/lib/components/ConnectionStatus.svelte"
      via: "component import"
      pattern: "ConnectionStatus"
---

<objective>
Create the browser-side connection management with session code entry, connection status display, and automatic reconnection using reconnecting-websocket.

Purpose: This is the browser UI that users interact with. They enter the session code from their Mac, see connection status, and rely on automatic reconnection to maintain the connection.

Output: A login page with session code input, connection status indicator visible throughout the app, and reliable WebSocket connection with auto-reconnect.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-connection-authentication/01-RESEARCH.md
@.planning/phases/01-connection-authentication/01-01-SUMMARY.md

# Shared types from Plan 01:
@src/shared/protocol.ts
@src/shared/constants.ts

# Existing files to understand current patterns:
@src/routes/login/+page.svelte
@src/lib/stores/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install reconnecting-websocket and create connection store</name>
  <files>
    package.json
    src/lib/stores/connection.ts
  </files>
  <action>
1. Install reconnecting-websocket:
   ```bash
   pnpm add reconnecting-websocket
   ```

2. Create src/lib/stores/connection.ts (replace existing websocket.ts patterns):

   Define connection state type (matching research):
   ```typescript
   export type ConnectionState =
     | 'disconnected'
     | 'connecting'
     | 'authenticating'
     | 'connected'
     | 'reconnecting';
   ```

   Create Svelte 5 runes-based store:
   ```typescript
   import ReconnectingWebSocket from 'reconnecting-websocket';

   // Store state
   let state = $state<ConnectionState>('disconnected');
   let error = $state<string | null>(null);
   let ws: ReconnectingWebSocket | null = null;
   let currentCode: string | null = null;

   // Exported reactive getters
   export const connectionStore = {
     get state() { return state; },
     get error() { return error; },
     get isConnected() { return state === 'connected'; }
   };
   ```

   Connection function:
   ```typescript
   export function connect(sessionCode: string): void {
     if (ws) {
       ws.close();
     }

     state = 'connecting';
     error = null;
     currentCode = sessionCode;

     const relayUrl = import.meta.env.VITE_RELAY_URL || 'ws://localhost:8080/browser';

     ws = new ReconnectingWebSocket(relayUrl, [], {
       maxReconnectionDelay: 30000,
       minReconnectionDelay: 1000,
       reconnectionDelayGrowFactor: 2,
       maxRetries: 10,
     });

     ws.addEventListener('open', handleOpen);
     ws.addEventListener('message', handleMessage);
     ws.addEventListener('close', handleClose);
     ws.addEventListener('error', handleError);
   }
   ```

   Event handlers:
   - handleOpen: transition to 'authenticating', send JoinMessage { type: 'join', code: currentCode }
   - handleMessage: parse response
     - If JoinedMessage: transition to 'connected', clear error
     - If ErrorMessage: set error to message, transition to 'disconnected', close ws
     - If DataMessage: emit to terminal (placeholder for Phase 2)
   - handleClose: if was connected, transition to 'reconnecting'; else 'disconnected'
   - handleError: log but don't set error (reconnecting-websocket handles retries)

   Disconnect function:
   ```typescript
   export function disconnect(): void {
     if (ws) {
       ws.close();
       ws = null;
     }
     state = 'disconnected';
     error = null;
     currentCode = null;
   }
   ```

   Send function (for later use):
   ```typescript
   export function send(payload: string): void {
     if (state === 'connected' && ws?.readyState === WebSocket.OPEN) {
       ws.send(JSON.stringify({ type: 'data', payload }));
     }
   }
   ```
  </action>
  <verify>
    - `pnpm list reconnecting-websocket` shows installed
    - `pnpm check` passes (Svelte/TypeScript check)
  </verify>
  <done>
    Connection store exists with connect/disconnect/send functions and reactive state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create connection status component</name>
  <files>
    src/lib/components/ConnectionStatus.svelte
  </files>
  <action>
Create src/lib/components/ConnectionStatus.svelte:

```svelte
<script lang="ts">
  import { connectionStore } from '$lib/stores/connection';

  // Map state to display info
  const stateDisplay = {
    disconnected: { label: 'Disconnected', color: 'text-gray-500', icon: '○' },
    connecting: { label: 'Connecting...', color: 'text-yellow-500', icon: '◐' },
    authenticating: { label: 'Authenticating...', color: 'text-yellow-500', icon: '◑' },
    connected: { label: 'Connected', color: 'text-green-500', icon: '●' },
    reconnecting: { label: 'Reconnecting...', color: 'text-orange-500', icon: '◐' },
  };

  // Reactive derivation
  let display = $derived(stateDisplay[connectionStore.state]);
</script>

<div class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-gray-800/50 text-sm">
  <span class={display.color}>{display.icon}</span>
  <span class={display.color}>{display.label}</span>
</div>
```

Features:
- Shows current connection state with icon and label
- Color-coded: green (connected), yellow (connecting/authenticating), orange (reconnecting), gray (disconnected)
- Compact pill design suitable for header/status bar
- Uses Tailwind classes (already in project based on existing components)
  </action>
  <verify>
    Component renders without errors when imported into a page
  </verify>
  <done>
    ConnectionStatus component displays current state with appropriate visual feedback.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update login page and integrate status into main layout</name>
  <files>
    src/routes/login/+page.svelte
    src/routes/+page.svelte
    src/routes/+layout.svelte
  </files>
  <action>
1. Update src/routes/login/+page.svelte for session code entry:

```svelte
<script lang="ts">
  import { goto } from '$app/navigation';
  import { connectionStore, connect } from '$lib/stores/connection';

  let sessionCode = $state('');
  let isSubmitting = $state(false);

  // Watch for successful connection
  $effect(() => {
    if (connectionStore.state === 'connected') {
      goto('/');
    }
  });

  function handleSubmit(e: SubmitEvent) {
    e.preventDefault();

    // Normalize: uppercase, remove spaces
    const code = sessionCode.toUpperCase().replace(/\s/g, '');

    if (code.length !== 6) {
      // Could add validation error state
      return;
    }

    isSubmitting = true;
    connect(code);
  }
</script>

<div class="min-h-screen flex items-center justify-center bg-gray-900 text-white">
  <div class="w-full max-w-sm p-8">
    <h1 class="text-2xl font-bold text-center mb-8">Connect to Terminal</h1>

    <form onsubmit={handleSubmit} class="space-y-6">
      <div>
        <label for="code" class="block text-sm font-medium text-gray-300 mb-2">
          Session Code
        </label>
        <input
          id="code"
          type="text"
          bind:value={sessionCode}
          placeholder="Enter 6-character code"
          maxlength="6"
          autocomplete="off"
          autocapitalize="characters"
          class="w-full px-4 py-3 bg-gray-800 border border-gray-700 rounded-lg
                 text-center text-2xl tracking-widest font-mono uppercase
                 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          disabled={isSubmitting}
        />
        <p class="mt-2 text-sm text-gray-400 text-center">
          Enter the code shown on your Mac
        </p>
      </div>

      {#if connectionStore.error}
        <div class="p-3 bg-red-900/50 border border-red-700 rounded-lg text-red-200 text-sm text-center">
          {connectionStore.error}
        </div>
      {/if}

      <button
        type="submit"
        disabled={sessionCode.length !== 6 || isSubmitting}
        class="w-full py-3 px-4 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-700
               disabled:cursor-not-allowed rounded-lg font-medium transition-colors"
      >
        {#if connectionStore.state === 'connecting' || connectionStore.state === 'authenticating'}
          Connecting...
        {:else}
          Connect
        {/if}
      </button>
    </form>
  </div>
</div>
```

2. Update src/routes/+layout.svelte to include ConnectionStatus in header:

Add import and render ConnectionStatus component in the layout's header area.
If no header exists, create a simple header bar:
```svelte
<script lang="ts">
  import ConnectionStatus from '$lib/components/ConnectionStatus.svelte';
  import { connectionStore } from '$lib/stores/connection';
</script>

{#if connectionStore.state !== 'disconnected'}
  <header class="fixed top-0 right-0 p-4 z-50">
    <ConnectionStatus />
  </header>
{/if}

<slot />
```

3. Update src/routes/+page.svelte to redirect to login if not connected:

```svelte
<script lang="ts">
  import { goto } from '$app/navigation';
  import { connectionStore, disconnect } from '$lib/stores/connection';
  import { onMount } from 'svelte';

  onMount(() => {
    if (connectionStore.state !== 'connected') {
      goto('/login');
    }
  });

  // Watch for disconnection
  $effect(() => {
    if (connectionStore.state === 'disconnected') {
      goto('/login');
    }
  });
</script>

<main class="min-h-screen bg-gray-900 text-white p-4">
  <h1 class="text-xl font-bold mb-4">Terminal</h1>
  <p class="text-gray-400">Terminal component will be added in Phase 2</p>

  <button
    onclick={() => disconnect()}
    class="mt-4 px-4 py-2 bg-red-600 hover:bg-red-700 rounded"
  >
    Disconnect
  </button>
</main>
```
  </action>
  <verify>
    1. `pnpm dev` starts without errors
    2. Visit http://localhost:5173/login - see session code input
    3. Enter invalid code - see error message from relay
    4. Enter valid code (from running Mac client) - redirects to main page
    5. Connection status visible in header showing "Connected"
    6. Kill relay - status changes to "Reconnecting..."
    7. Click Disconnect - returns to login page
  </verify>
  <done>
    Login page accepts session code, shows errors, redirects on success. Connection status visible throughout app.
  </done>
</task>

</tasks>

<verification>
1. Browser shows login page at /login with session code input
2. Invalid code (wrong characters) shows "Session code not found" error
3. Expired code shows appropriate error message
4. Valid code connects and redirects to main page
5. ConnectionStatus component shows correct state (connected/reconnecting/etc)
6. Network interruption triggers visible "Reconnecting..." state
7. Reconnection succeeds automatically when relay is back
8. Disconnect button returns to login page
</verification>

<success_criteria>
- Session code input is user-friendly (auto-uppercase, tracking, mono font)
- Error messages from relay are displayed clearly to user
- Connection status visible at all times when not on login page
- Uses reconnecting-websocket for automatic recovery
- State transitions are reflected immediately in UI
- Navigation flow: login -> main (on connect), main -> login (on disconnect)
</success_criteria>

<output>
After completion, create `.planning/phases/01-connection-authentication/01-03-SUMMARY.md`
</output>
