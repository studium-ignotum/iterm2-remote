---
phase: 01-connection-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/shared/protocol.ts
  - src/shared/constants.ts
  - src/shared/session-codes.ts
  - src/relay/server.ts
  - src/relay/session-registry.ts
autonomous: true

must_haves:
  truths:
    - "Relay server starts and listens on configured port"
    - "Mac client can connect at /mac endpoint and receive session code"
    - "Browser can connect at /browser endpoint and join with code"
    - "Invalid session codes return clear error message"
    - "Expired session codes are rejected"
  artifacts:
    - path: "src/shared/protocol.ts"
      provides: "Zod message schemas for all WebSocket communication"
      exports: ["RegisterMessage", "RegisteredMessage", "JoinMessage", "JoinedMessage", "ErrorMessage", "DataMessage", "IncomingMessage"]
    - path: "src/shared/constants.ts"
      provides: "Configuration constants"
      contains: "SESSION_CODE_EXPIRY"
    - path: "src/shared/session-codes.ts"
      provides: "Session code generation"
      exports: ["generateSessionCode"]
    - path: "src/relay/server.ts"
      provides: "WebSocket relay server"
      min_lines: 50
    - path: "src/relay/session-registry.ts"
      provides: "Session code to connection mapping"
      exports: ["SessionRegistry"]
  key_links:
    - from: "src/relay/server.ts"
      to: "src/relay/session-registry.ts"
      via: "import and usage"
      pattern: "import.*SessionRegistry"
    - from: "src/relay/server.ts"
      to: "src/shared/protocol.ts"
      via: "message validation"
      pattern: "safeParse|IncomingMessage"
    - from: "src/relay/session-registry.ts"
      to: "src/shared/session-codes.ts"
      via: "code generation"
      pattern: "generateSessionCode"
---

<objective>
Create the shared protocol types and relay server that handles WebSocket connections from Mac clients and browsers, routing messages between paired connections via session codes.

Purpose: This is the core infrastructure that all clients connect to. Without a working relay with proper message validation and session management, nothing else can function.

Output: A running relay server that can accept /mac and /browser connections, generate session codes, validate join attempts, and route messages between paired connections.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-connection-authentication/01-RESEARCH.md

# Existing files to understand (will be replaced):
@server.js
@src/lib/server/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create shared protocol</name>
  <files>
    package.json
    src/shared/protocol.ts
    src/shared/constants.ts
    src/shared/session-codes.ts
  </files>
  <action>
1. Install required dependencies:
   ```bash
   pnpm add nanoid zod
   pnpm add -D @types/ws
   ```
   Note: ws is already installed (8.18.0), close enough to research recommendation (8.19.0)

2. Create src/shared/constants.ts with configuration:
   - SESSION_CODE_EXPIRY_MS: 5 * 60 * 1000 (5 minutes)
   - SESSION_CODE_LENGTH: 6
   - SESSION_CODE_ALPHABET: '346789ABCDEFGHJKLMNPQRTUVWXY' (nolookalikes)
   - HEARTBEAT_INTERVAL_MS: 30000
   - HEARTBEAT_TIMEOUT_MS: 10000
   - DEFAULT_RELAY_PORT: 8080

3. Create src/shared/session-codes.ts:
   - Import customAlphabet from nanoid
   - Export generateSessionCode using alphabet and length from constants
   - Example output: "H4F7KN"

4. Create src/shared/protocol.ts with Zod schemas (from research):
   - RegisterMessage: { type: 'register', clientId: string (uuid) }
   - RegisteredMessage: { type: 'registered', code: string (6 chars), expiresAt: number }
   - JoinMessage: { type: 'join', code: string (6 chars) }
   - JoinedMessage: { type: 'joined', sessionId: string (uuid) }
   - ErrorMessage: { type: 'error', code: enum, message: string }
   - DataMessage: { type: 'data', payload: string }
   - PingMessage: { type: 'ping', ts: number }
   - PongMessage: { type: 'pong', ts: number }
   - Create discriminated union IncomingMessage for parsing
   - Export parseMessage utility function
  </action>
  <verify>
    - `pnpm list nanoid zod` shows both installed
    - `npx tsc --noEmit src/shared/*.ts` compiles without errors
  </verify>
  <done>
    All shared types exist and compile. Session code generation produces 6-char uppercase codes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session registry</name>
  <files>
    src/relay/session-registry.ts
  </files>
  <action>
Create src/relay/session-registry.ts implementing session management:

1. Define Session interface:
   ```typescript
   interface Session {
     code: string;
     mac: WebSocket | null;
     browser: WebSocket | null;
     createdAt: number;
     expiresAt: number;
   }
   ```

2. Create SessionRegistry class:
   - Private sessions Map<string, Session>
   - createSession(macSocket: WebSocket): Session
     - Generate code using generateSessionCode()
     - Set expiry using SESSION_CODE_EXPIRY_MS
     - Store in map, return session
   - getSession(code: string): Session | null
   - joinSession(code: string, browserSocket: WebSocket): { success: boolean, error?: string }
     - Validate code exists
     - Check not expired (Date.now() > expiresAt)
     - Check browser slot not taken
     - Return appropriate error codes: 'INVALID_CODE', 'EXPIRED_CODE', 'ALREADY_JOINED'
   - removeSession(code: string): void
   - findSessionByMac(socket: WebSocket): Session | null
   - findSessionByBrowser(socket: WebSocket): Session | null
   - cleanupExpired(): number (returns count of cleaned)

3. Use WeakMap or regular cleanup interval to avoid memory leaks.

4. Export singleton instance for use by server.
  </action>
  <verify>
    `npx tsc --noEmit src/relay/session-registry.ts` compiles without errors
  </verify>
  <done>
    SessionRegistry class exists with create/join/remove/find methods. Handles code expiry.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create relay WebSocket server</name>
  <files>
    src/relay/server.ts
  </files>
  <action>
Create src/relay/server.ts as the main relay server:

1. Import ws, session registry, protocol types, constants

2. Create WebSocketServer setup:
   ```typescript
   const wss = new WebSocketServer({ port: DEFAULT_RELAY_PORT });
   ```

3. Handle connections by path (req.url):
   - '/mac' -> handleMacConnection(ws)
   - '/browser' -> handleBrowserConnection(ws)
   - Other paths -> ws.close(4000, 'Invalid path')

4. handleMacConnection(ws):
   - Create session via registry (generates code)
   - Send RegisteredMessage with code and expiresAt
   - On message: validate with parseMessage, if DataMessage forward to session.browser
   - On close: notify browser if connected (ErrorMessage MAC_DISCONNECTED), remove session

5. handleBrowserConnection(ws):
   - Track joinedSession locally
   - On message:
     - If JoinMessage: validate code via registry.joinSession()
       - Success: send JoinedMessage, set joinedSession
       - Failure: send ErrorMessage with appropriate code
     - If DataMessage and joinedSession: forward to session.mac
   - On close: clear browser from session

6. Add heartbeat using ws ping/pong:
   - WeakMap<WebSocket, { isAlive: boolean }>
   - Set isAlive true on pong
   - Interval: check isAlive, terminate if false, ping if true
   - Clear interval on server close

7. Add startup logging: console.log(`Relay server listening on port ${port}`)

8. Export start function or make it auto-start based on env
  </action>
  <verify>
    Start server with `node --loader ts-node/esm src/relay/server.ts` or similar
    Verify "Relay server listening on port 8080" appears
    Use wscat or similar to test: `wscat -c ws://localhost:8080/mac` should receive registered message
  </verify>
  <done>
    Relay server starts, accepts /mac and /browser connections, generates codes, validates joins, routes messages.
  </done>
</task>

</tasks>

<verification>
1. Server starts without errors on configured port
2. Mac connection to /mac receives session code in RegisteredMessage
3. Browser connection to /browser can send JoinMessage
4. Valid code: receives JoinedMessage
5. Invalid code: receives ErrorMessage with INVALID_CODE
6. Expired code: receives ErrorMessage with EXPIRED_CODE
7. After join, messages route between Mac and browser
</verification>

<success_criteria>
- Shared protocol compiles with strict TypeScript
- Session codes are 6-char, uppercase, no ambiguous characters
- Relay server handles concurrent connections correctly
- Invalid/expired codes rejected with clear error codes
- Message routing works bidirectionally after successful join
</success_criteria>

<output>
After completion, create `.planning/phases/01-connection-authentication/01-01-SUMMARY.md`
</output>
