---
phase: 01-connection-authentication
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - mac-client/package.json
  - mac-client/src/connection.ts
  - mac-client/src/state-machine.ts
  - mac-client/src/index.ts
  - mac-client/tsconfig.json
autonomous: true

must_haves:
  truths:
    - "Mac client starts and connects to relay server"
    - "Session code is displayed to user in terminal"
    - "Client reconnects automatically after network interruption"
    - "Connection state transitions are logged clearly"
  artifacts:
    - path: "mac-client/src/connection.ts"
      provides: "WebSocket connection manager with reconnection"
      exports: ["ConnectionManager"]
    - path: "mac-client/src/state-machine.ts"
      provides: "Connection state machine"
      exports: ["ConnectionState", "canTransition"]
    - path: "mac-client/src/index.ts"
      provides: "Entry point that starts connection and displays code"
      min_lines: 20
  key_links:
    - from: "mac-client/src/index.ts"
      to: "mac-client/src/connection.ts"
      via: "import and instantiation"
      pattern: "import.*ConnectionManager"
    - from: "mac-client/src/connection.ts"
      to: "mac-client/src/state-machine.ts"
      via: "state management"
      pattern: "canTransition|ConnectionState"
---

<objective>
Create the Mac client that connects to the relay server, receives and displays the session code, and handles reconnection with exponential backoff.

Purpose: This is what runs on the user's Mac. It must reliably connect to the relay, display the session code so the user can enter it in their browser, and maintain the connection with automatic recovery from network issues.

Output: A Node.js application that can be run on Mac, connects to relay, displays session code, and auto-reconnects.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-connection-authentication/01-RESEARCH.md
@.planning/phases/01-connection-authentication/01-01-SUMMARY.md

# Shared types from Plan 01:
@src/shared/protocol.ts
@src/shared/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Mac client package structure</name>
  <files>
    mac-client/package.json
    mac-client/tsconfig.json
  </files>
  <action>
1. Create mac-client/ directory structure:
   ```
   mac-client/
   ├── package.json
   ├── tsconfig.json
   └── src/
       ├── connection.ts
       ├── state-machine.ts
       └── index.ts
   ```

2. Create mac-client/package.json:
   ```json
   {
     "name": "iterm-remote-mac-client",
     "version": "0.1.0",
     "private": true,
     "type": "module",
     "main": "dist/index.js",
     "scripts": {
       "build": "tsc",
       "start": "node dist/index.js",
       "dev": "tsx src/index.ts"
     },
     "dependencies": {
       "ws": "^8.18.0"
     },
     "devDependencies": {
       "@types/ws": "^8.5.0",
       "tsx": "^4.0.0",
       "typescript": "^5.0.0"
     }
   }
   ```

3. Create mac-client/tsconfig.json:
   ```json
   {
     "compilerOptions": {
       "target": "ES2022",
       "module": "ESNext",
       "moduleResolution": "bundler",
       "outDir": "dist",
       "rootDir": "src",
       "strict": true,
       "esModuleInterop": true,
       "skipLibCheck": true,
       "paths": {
         "@shared/*": ["../src/shared/*"]
       }
     },
     "include": ["src/**/*"]
   }
   ```

4. Install dependencies:
   ```bash
   cd mac-client && pnpm install
   ```
  </action>
  <verify>
    - mac-client/package.json exists with correct structure
    - `cd mac-client && pnpm list` shows ws, tsx, typescript installed
  </verify>
  <done>
    Mac client package structure exists with dependencies installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement connection state machine and manager</name>
  <files>
    mac-client/src/state-machine.ts
    mac-client/src/connection.ts
  </files>
  <action>
1. Create mac-client/src/state-machine.ts:
   ```typescript
   export type ConnectionState =
     | 'disconnected'
     | 'connecting'
     | 'authenticating'  // Waiting for session code
     | 'connected'       // Registered with code, ready
     | 'reconnecting';

   const STATE_TRANSITIONS: Record<ConnectionState, ConnectionState[]> = {
     disconnected: ['connecting'],
     connecting: ['authenticating', 'disconnected'],
     authenticating: ['connected', 'disconnected'],
     connected: ['reconnecting', 'disconnected'],
     reconnecting: ['connecting', 'disconnected'],
   };

   export function canTransition(from: ConnectionState, to: ConnectionState): boolean {
     return STATE_TRANSITIONS[from]?.includes(to) ?? false;
   }
   ```

2. Create mac-client/src/connection.ts with ConnectionManager class:

   Configuration (from constants or inline):
   - relayUrl: string (e.g., 'ws://localhost:8080/mac')
   - initialDelay: 1000ms
   - maxDelay: 30000ms
   - multiplier: 2
   - jitterFactor: 0.1

   Class structure:
   ```typescript
   export class ConnectionManager {
     private ws: WebSocket | null = null;
     private state: ConnectionState = 'disconnected';
     private attempt: number = 0;
     private sessionCode: string | null = null;
     private clientId: string;

     constructor(private relayUrl: string, private onCodeReceived: (code: string) => void) {
       this.clientId = crypto.randomUUID();
     }

     connect(): void { /* transition to connecting, create WebSocket */ }
     private handleOpen(): void { /* send register message, transition to authenticating */ }
     private handleMessage(data: Buffer): void { /* parse, handle registered/error */ }
     private handleClose(): void { /* transition to reconnecting, schedule retry */ }
     private handleError(err: Error): void { /* log error */ }
     private scheduleReconnect(): void { /* calculate backoff, setTimeout */ }
     private calculateBackoff(): number { /* exponential with jitter */ }
     disconnect(): void { /* clean shutdown */ }

     getState(): ConnectionState { return this.state; }
     getSessionCode(): string | null { return this.sessionCode; }
   }
   ```

   Key behaviors:
   - On open: Send RegisterMessage { type: 'register', clientId }
   - On registered message: Store code, call onCodeReceived callback, transition to 'connected'
   - On close/error: Transition to 'reconnecting', schedule reconnect with backoff
   - Reset attempt counter on successful connection
   - Log state transitions for debugging

   Exponential backoff formula (from research):
   ```typescript
   const exponentialDelay = initialDelay * Math.pow(multiplier, attempt);
   const cappedDelay = Math.min(exponentialDelay, maxDelay);
   const jitter = cappedDelay * jitterFactor * (Math.random() * 2 - 1);
   return Math.floor(cappedDelay + jitter);
   ```
  </action>
  <verify>
    `cd mac-client && npx tsc --noEmit` compiles without errors
  </verify>
  <done>
    State machine and ConnectionManager exist with reconnection logic.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create entry point and test connection</name>
  <files>
    mac-client/src/index.ts
  </files>
  <action>
1. Create mac-client/src/index.ts:
   ```typescript
   import { ConnectionManager } from './connection.js';

   const RELAY_URL = process.env.RELAY_URL || 'ws://localhost:8080/mac';

   console.log('iTerm2 Remote - Mac Client');
   console.log('==========================');
   console.log(`Connecting to relay: ${RELAY_URL}`);
   console.log();

   const manager = new ConnectionManager(RELAY_URL, (code) => {
     console.log();
     console.log('╔════════════════════════════════════╗');
     console.log('║                                    ║');
     console.log(`║     Session Code: ${code}          ║`);
     console.log('║                                    ║');
     console.log('║  Enter this code in your browser   ║');
     console.log('║  to connect to this terminal.      ║');
     console.log('║                                    ║');
     console.log('╚════════════════════════════════════╝');
     console.log();
   });

   // Handle graceful shutdown
   process.on('SIGINT', () => {
     console.log('\nShutting down...');
     manager.disconnect();
     process.exit(0);
   });

   process.on('SIGTERM', () => {
     manager.disconnect();
     process.exit(0);
   });

   // Start connection
   manager.connect();
   ```

2. Add state change logging in ConnectionManager (if not already):
   ```typescript
   private transition(to: ConnectionState): boolean {
     if (!canTransition(this.state, to)) {
       console.warn(`Invalid transition: ${this.state} -> ${to}`);
       return false;
     }
     console.log(`[Connection] ${this.state} -> ${to}`);
     this.state = to;
     return true;
   }
   ```

3. Test the full flow:
   - Start relay server (from Plan 01): `node --loader ts-node/esm src/relay/server.ts`
   - In another terminal, start Mac client: `cd mac-client && pnpm dev`
   - Verify session code appears
   - Kill relay, verify reconnection attempts with backoff
   - Restart relay, verify successful reconnection
  </action>
  <verify>
    1. `cd mac-client && pnpm dev` starts and shows "Connecting to relay"
    2. Session code box appears with 6-character code
    3. Killing relay triggers reconnection logs with increasing delays
    4. Restarting relay shows successful reconnection and new code
  </verify>
  <done>
    Mac client runs, displays session code prominently, reconnects automatically with backoff.
  </done>
</task>

</tasks>

<verification>
1. Mac client package builds without TypeScript errors
2. Client connects to relay and receives session code
3. Session code is displayed clearly with visual formatting
4. Network interruption triggers reconnection with exponential backoff
5. Reconnection succeeds and displays new session code
6. SIGINT/SIGTERM gracefully disconnects
</verification>

<success_criteria>
- Mac client is a standalone Node.js package
- Uses shared protocol types for messages
- State machine prevents invalid transitions
- Reconnection uses exponential backoff with jitter (1s -> 2s -> 4s -> ... -> 30s max)
- Session code displayed prominently so user can read it
- Clean shutdown on SIGINT/SIGTERM
</success_criteria>

<output>
After completion, create `.planning/phases/01-connection-authentication/01-02-SUMMARY.md`
</output>
