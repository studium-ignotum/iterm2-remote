---
phase: 04-relay-server
plan: 04
type: execute
wave: 4
depends_on: ["04-02", "04-03"]
files_modified:
  - relay-server-v2/src/handlers/mod.rs
  - relay-server-v2/src/handlers/ws.rs
  - relay-server-v2/src/state.rs
  - relay-server-v2/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Mac-client can connect via WebSocket and receive a session code"
    - "Browser can authenticate with valid session code"
    - "Browser with invalid code receives AuthFailed message"
    - "Messages from mac-client are routed to connected browser"
    - "Messages from browser are routed to mac-client"
    - "Disconnected clients are cleaned up from state"
  artifacts:
    - path: "relay-server-v2/src/handlers/ws.rs"
      provides: "WebSocket connection handling"
      contains: "WebSocketUpgrade"
    - path: "relay-server-v2/src/handlers/mod.rs"
      provides: "Handler module exports"
      contains: "ws_handler"
  key_links:
    - from: "relay-server-v2/src/handlers/ws.rs"
      to: "relay-server-v2/src/state.rs"
      via: "state access"
      pattern: "State<AppState>"
    - from: "relay-server-v2/src/handlers/ws.rs"
      to: "relay-server-v2/src/protocol.rs"
      via: "message parsing"
      pattern: "ControlMessage"
    - from: "relay-server-v2/src/main.rs"
      to: "relay-server-v2/src/handlers/ws.rs"
      via: "route handler"
      pattern: 'route\\("/ws"'
---

<objective>
Implement the WebSocket handler with client differentiation, authentication, and bidirectional message routing.

Purpose: This is the core relay functionality - connecting mac-clients to browsers and routing terminal data between them.
Output: Working WebSocket endpoint that handles mac-client registration, browser authentication, and message routing.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-relay-server/04-RESEARCH.md
@.planning/phases/04-relay-server/04-01-SUMMARY.md
@.planning/phases/04-relay-server/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket handler with client differentiation</name>
  <files>relay-server-v2/src/handlers/mod.rs, relay-server-v2/src/handlers/ws.rs, relay-server-v2/src/main.rs</files>
  <action>
Create the handlers module with WebSocket upgrade handler.

Create src/handlers/mod.rs:
```rust
mod ws;
pub use ws::ws_handler;
```

Create src/handlers/ws.rs with the WebSocket upgrade and client type detection:

```rust
use axum::{
    extract::{ws::{Message, WebSocket, WebSocketUpgrade}, State},
    response::IntoResponse,
};
use futures_util::{SinkExt, StreamExt};
use tokio::sync::mpsc;

use crate::protocol::ControlMessage;
use crate::state::AppState;

pub async fn ws_handler(
    ws: WebSocketUpgrade,
    State(state): State<AppState>,
) -> impl IntoResponse {
    ws.on_upgrade(|socket| handle_socket(socket, state))
}

async fn handle_socket(socket: WebSocket, state: AppState) {
    let (mut sender, mut receiver) = socket.split();

    // Wait for first message to determine client type
    let Some(Ok(first_msg)) = receiver.next().await else {
        tracing::debug!("Client disconnected before sending first message");
        return;
    };

    // Parse first message as JSON to determine client type
    let Message::Text(text) = first_msg else {
        tracing::warn!("First message must be JSON Text, got binary");
        let _ = sender.send(Message::Text(
            serde_json::to_string(&ControlMessage::Error {
                message: "First message must be JSON".into(),
            }).unwrap().into()
        )).await;
        return;
    };

    let Ok(control_msg) = serde_json::from_str::<ControlMessage>(&text) else {
        tracing::warn!("Invalid JSON in first message");
        let _ = sender.send(Message::Text(
            serde_json::to_string(&ControlMessage::Error {
                message: "Invalid JSON".into(),
            }).unwrap().into()
        )).await;
        return;
    };

    match control_msg {
        ControlMessage::Register { client_id } => {
            handle_mac_client(sender, receiver, state, client_id).await;
        }
        ControlMessage::Auth { session_code } => {
            handle_browser(sender, receiver, state, session_code).await;
        }
        _ => {
            tracing::warn!("Unexpected first message type");
            let _ = sender.send(Message::Text(
                serde_json::to_string(&ControlMessage::Error {
                    message: "First message must be Register or Auth".into(),
                }).unwrap().into()
            )).await;
        }
    }
}
```

Update main.rs:
1. Add `mod handlers;`
2. Replace `ws_handler_placeholder` with `handlers::ws_handler`
3. Update the route: `.route("/ws", get(handlers::ws_handler))`
  </action>
  <verify>
```bash
cd relay-server-v2 && cargo build 2>&1 | tail -5
```
  </verify>
  <done>WebSocket handler compiles and routes to client type handlers</done>
</task>

<task type="auto">
  <name>Task 2: Implement mac-client and browser connection flows</name>
  <files>relay-server-v2/src/handlers/ws.rs, relay-server-v2/src/state.rs</files>
  <action>
Add mac-client and browser handling to ws.rs.

Add to ws.rs:

```rust
/// Handle a mac-client connection
async fn handle_mac_client(
    mut sender: futures_util::stream::SplitSink<WebSocket, Message>,
    mut receiver: futures_util::stream::SplitStream<WebSocket>,
    state: AppState,
    client_id: String,
) {
    // Create channel for receiving messages to send to mac-client
    let (mac_tx, mut mac_rx) = mpsc::channel::<Vec<u8>>(1000);

    // Register and get session code
    let code = state.register_mac_client(client_id.clone(), mac_tx);

    // Send registration confirmation
    let response = ControlMessage::Registered { code: code.clone() };
    if sender.send(Message::Text(
        serde_json::to_string(&response).unwrap().into()
    )).await.is_err() {
        state.remove_session(&code);
        return;
    }

    tracing::info!(code = %code, client_id = %client_id, "Mac-client connected");

    // Spawn task to forward messages from browsers to mac-client
    let code_clone = code.clone();
    let send_task = tokio::spawn(async move {
        while let Some(data) = mac_rx.recv().await {
            if sender.send(Message::Binary(data.into())).await.is_err() {
                break;
            }
        }
    });

    // Process incoming messages from mac-client (terminal output)
    while let Some(msg_result) = receiver.next().await {
        match msg_result {
            Ok(Message::Binary(data)) => {
                // Forward terminal output to all connected browsers
                state.broadcast_to_browsers(&code_clone, data.to_vec()).await;
            }
            Ok(Message::Text(text)) => {
                // Handle control messages from mac-client
                if let Ok(ctrl) = serde_json::from_str::<ControlMessage>(&text) {
                    tracing::debug!(code = %code_clone, "Mac-client control: {:?}", ctrl);
                    // Handle other control messages as needed
                }
            }
            Ok(Message::Close(_)) => break,
            Err(e) => {
                tracing::debug!(code = %code_clone, "Mac-client error: {}", e);
                break;
            }
            _ => {} // Ignore ping/pong
        }
    }

    // Cleanup
    send_task.abort();
    state.remove_session(&code_clone);
    tracing::info!(code = %code_clone, "Mac-client disconnected");
}

/// Handle a browser connection
async fn handle_browser(
    mut sender: futures_util::stream::SplitSink<WebSocket, Message>,
    mut receiver: futures_util::stream::SplitStream<WebSocket>,
    state: AppState,
    session_code: String,
) {
    let code = session_code.to_uppercase();

    // Validate session code
    if !state.validate_session_code(&code) {
        let response = ControlMessage::AuthFailed {
            reason: "Invalid session code".into(),
        };
        let _ = sender.send(Message::Text(
            serde_json::to_string(&response).unwrap().into()
        )).await;
        tracing::info!(code = %code, "Browser auth failed - invalid code");
        return;
    }

    // Create channel for receiving terminal output
    let (browser_tx, mut browser_rx) = mpsc::channel::<Vec<u8>>(1000);
    let browser_id = nanoid::nanoid!(8);

    // Register browser with session
    state.add_browser(&code, browser_id.clone(), browser_tx);

    // Send auth success
    let response = ControlMessage::AuthSuccess;
    if sender.send(Message::Text(
        serde_json::to_string(&response).unwrap().into()
    )).await.is_err() {
        state.remove_browser(&code, &browser_id);
        return;
    }

    tracing::info!(code = %code, browser_id = %browser_id, "Browser connected");

    // Spawn task to forward terminal output to browser
    let code_clone = code.clone();
    let browser_id_clone = browser_id.clone();
    let send_task = tokio::spawn(async move {
        while let Some(data) = browser_rx.recv().await {
            if sender.send(Message::Binary(data.into())).await.is_err() {
                break;
            }
        }
    });

    // Process incoming messages from browser (keyboard input)
    while let Some(msg_result) = receiver.next().await {
        match msg_result {
            Ok(Message::Binary(data)) => {
                // Forward keyboard input to mac-client
                state.send_to_mac_client(&code_clone, data.to_vec()).await;
            }
            Ok(Message::Text(text)) => {
                // Handle control messages from browser
                if let Ok(ctrl) = serde_json::from_str::<ControlMessage>(&text) {
                    tracing::debug!(code = %code_clone, "Browser control: {:?}", ctrl);
                }
            }
            Ok(Message::Close(_)) => break,
            Err(e) => {
                tracing::debug!(code = %code_clone, "Browser error: {}", e);
                break;
            }
            _ => {}
        }
    }

    // Cleanup
    send_task.abort();
    state.remove_browser(&code_clone, &browser_id_clone);
    tracing::info!(code = %code_clone, browser_id = %browser_id_clone, "Browser disconnected");
}
```

Update state.rs to support browser tracking and message routing:

```rust
// Add to Session struct:
pub struct Session {
    pub code: String,
    pub client_id: String,
    pub mac_tx: mpsc::Sender<Vec<u8>>,
    pub browsers: DashMap<String, mpsc::Sender<Vec<u8>>>,  // browser_id -> sender
}

// Update register_mac_client to initialize browsers:
self.inner.sessions.insert(
    code.clone(),
    Session {
        code: code.clone(),
        client_id,
        mac_tx,
        browsers: DashMap::new(),
    },
);

// Add these methods to AppState impl:

/// Add a browser to a session
pub fn add_browser(&self, code: &str, browser_id: String, tx: mpsc::Sender<Vec<u8>>) {
    if let Some(session) = self.inner.sessions.get(code) {
        session.browsers.insert(browser_id, tx);
    }
}

/// Remove a browser from a session
pub fn remove_browser(&self, code: &str, browser_id: &str) {
    if let Some(session) = self.inner.sessions.get(code) {
        session.browsers.remove(browser_id);
    }
}

/// Broadcast terminal output to all browsers in a session
pub async fn broadcast_to_browsers(&self, code: &str, data: Vec<u8>) {
    if let Some(session) = self.inner.sessions.get(code) {
        for entry in session.browsers.iter() {
            let _ = entry.value().send(data.clone()).await;
        }
    }
}

/// Send keyboard input to mac-client
pub async fn send_to_mac_client(&self, code: &str, data: Vec<u8>) {
    if let Some(session) = self.inner.sessions.get(code) {
        let _ = session.mac_tx.send(data).await;
    }
}
```
  </action>
  <verify>
```bash
cd relay-server-v2 && cargo build 2>&1 | tail -5
```
  </verify>
  <done>Mac-client registration and browser authentication flows compile</done>
</task>

<task type="auto">
  <name>Task 3: Integration test with websocat</name>
  <files>relay-server-v2/test-ws.sh</files>
  <action>
Test the full flow using websocat (WebSocket CLI tool).

1. Ensure websocat is installed: `brew install websocat` or `cargo install websocat`

2. Start the server:
```bash
cd relay-server-v2 && RUST_LOG=info cargo run
```

3. In terminal 2, connect as mac-client:
```bash
echo '{"type":"register","client_id":"test-mac"}' | websocat ws://localhost:3000/ws
```
Should receive: `{"type":"registered","code":"XXXXXX"}`

4. In terminal 3, connect as browser with the received code:
```bash
echo '{"type":"auth","session_code":"XXXXXX"}' | websocat ws://localhost:3000/ws
```
Should receive: `{"type":"auth_success"}`

5. Test invalid code:
```bash
echo '{"type":"auth","session_code":"INVALID"}' | websocat ws://localhost:3000/ws
```
Should receive: `{"type":"auth_failed","reason":"Invalid session code"}`

6. Test message routing (requires keeping connections open):
```bash
# Terminal 2 (mac-client) - keep open:
websocat ws://localhost:3000/ws
# Type: {"type":"register","client_id":"test-mac"}
# Note the code received

# Terminal 3 (browser) - keep open:
websocat ws://localhost:3000/ws
# Type: {"type":"auth","session_code":"CODE_HERE"}
# Should see auth_success

# From mac-client terminal, send binary (as text for testing):
# Terminal output would be binary, but for testing JSON works
```

Add a simple smoke test script at relay-server-v2/test-ws.sh:
```bash
#!/bin/bash
set -e

echo "Starting server..."
cargo build --release
./target/release/relay-server &
SERVER_PID=$!
sleep 2

echo "Testing mac-client registration..."
RESPONSE=$(echo '{"type":"register","client_id":"test"}' | websocat -n1 ws://localhost:3000/ws 2>/dev/null)
echo "Response: $RESPONSE"

if echo "$RESPONSE" | grep -q '"type":"registered"'; then
    echo "PASS: Mac-client registration works"
else
    echo "FAIL: Mac-client registration failed"
    kill $SERVER_PID 2>/dev/null
    exit 1
fi

# Extract code from response
CODE=$(echo "$RESPONSE" | grep -o '"code":"[^"]*"' | cut -d'"' -f4)
echo "Session code: $CODE"

echo "Testing browser auth with valid code..."
RESPONSE=$(echo "{\"type\":\"auth\",\"session_code\":\"$CODE\"}" | websocat -n1 ws://localhost:3000/ws 2>/dev/null)
echo "Response: $RESPONSE"

if echo "$RESPONSE" | grep -q '"type":"auth_success"'; then
    echo "PASS: Browser auth works"
else
    echo "FAIL: Browser auth failed"
    kill $SERVER_PID 2>/dev/null
    exit 1
fi

echo "Testing browser auth with invalid code..."
RESPONSE=$(echo '{"type":"auth","session_code":"BADCODE"}' | websocat -n1 ws://localhost:3000/ws 2>/dev/null)
echo "Response: $RESPONSE"

if echo "$RESPONSE" | grep -q '"type":"auth_failed"'; then
    echo "PASS: Invalid code rejected"
else
    echo "FAIL: Invalid code not rejected"
    kill $SERVER_PID 2>/dev/null
    exit 1
fi

echo ""
echo "All tests passed!"
kill $SERVER_PID 2>/dev/null
```

Make it executable: `chmod +x relay-server-v2/test-ws.sh`
  </action>
  <verify>
```bash
# Install websocat if needed
which websocat || cargo install websocat

# Run the test script
cd relay-server-v2 && ./test-ws.sh
```
  </verify>
  <done>WebSocket flow works: mac-client gets code, browser authenticates, invalid codes rejected</done>
</task>

</tasks>

<verification>
1. Server compiles and runs
2. Mac-client can connect and receive session code
3. Browser can authenticate with valid code
4. Invalid codes are rejected with clear error
5. test-ws.sh passes all checks
</verification>

<success_criteria>
Phase 4 success criteria (from ROADMAP.md):
1. Single binary runs with embedded web UI - VERIFIED (Plan 03)
2. Mac-client connects via WebSocket and registers - VERIFIED (this plan)
3. Browser connects and authenticates with session code - VERIFIED (this plan)
4. Messages route between mac-client and browser - VERIFIED (broadcast_to_browsers, send_to_mac_client)
5. Invalid session codes rejected with clear error - VERIFIED (AuthFailed response)
</success_criteria>

<output>
After completion, create `.planning/phases/04-relay-server/04-04-SUMMARY.md`
</output>
