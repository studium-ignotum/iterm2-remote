---
phase: 04-relay-server
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - relay-server-v2/src/state.rs
  - relay-server-v2/src/session.rs
  - relay-server-v2/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Session codes are 6 uppercase alphanumeric characters"
    - "Generated codes are collision-checked before assignment"
    - "AppState can register mac-clients and track sessions"
    - "AppState can validate session codes for browser authentication"
  artifacts:
    - path: "relay-server-v2/src/state.rs"
      provides: "Application state with session storage"
      contains: "DashMap"
    - path: "relay-server-v2/src/session.rs"
      provides: "Session code generation"
      contains: "nanoid"
  key_links:
    - from: "relay-server-v2/src/state.rs"
      to: "relay-server-v2/src/session.rs"
      via: "code generation"
      pattern: "generate_session_code"
    - from: "relay-server-v2/src/main.rs"
      to: "relay-server-v2/src/state.rs"
      via: "shared state"
      pattern: "AppState"
---

<objective>
Implement session state management and session code generation for the relay server.

Purpose: Enable the relay to track connected mac-clients, generate unique session codes, and validate codes when browsers authenticate.
Output: AppState struct with DashMap storage and session code generation with collision checking.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-relay-server/04-RESEARCH.md
@.planning/phases/04-relay-server/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session code generation</name>
  <files>relay-server-v2/src/session.rs</files>
  <action>
Create src/session.rs with session code generation using nanoid.

Requirements:
- 6-character codes using uppercase alphanumeric (A-Z, 0-9)
- Exclude confusing characters: 0/O and 1/I/L (ambiguous when typed)
- Use custom alphabet: "ABCDEFGHJKMNPQRSTUVWXYZ23456789" (excludes 0,O,1,I,L)

```rust
use nanoid::nanoid;

/// Characters for session codes - excludes 0/O/1/I/L to avoid confusion
const CODE_ALPHABET: [char; 31] = [
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K',
    'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
    'X', 'Y', 'Z', '2', '3', '4', '5', '6', '7', '8', '9',
];

/// Generate a 6-character session code
pub fn generate_session_code() -> String {
    nanoid!(6, &CODE_ALPHABET)
}
```

Add a test to verify code format:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_code_length() {
        let code = generate_session_code();
        assert_eq!(code.len(), 6);
    }

    #[test]
    fn test_code_alphabet() {
        let code = generate_session_code();
        for c in code.chars() {
            assert!(CODE_ALPHABET.contains(&c), "Invalid char: {}", c);
        }
    }

    #[test]
    fn test_no_confusing_chars() {
        // Generate many codes and verify none contain confusing chars
        for _ in 0..100 {
            let code = generate_session_code();
            assert!(!code.contains('0'));
            assert!(!code.contains('O'));
            assert!(!code.contains('1'));
            assert!(!code.contains('I'));
            assert!(!code.contains('L'));
        }
    }
}
```
  </action>
  <verify>
```bash
cd relay-server-v2 && cargo test session:: 2>&1 | tail -10
```
  </verify>
  <done>Session code generation works with clean alphabet, all tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Create AppState with session storage</name>
  <files>relay-server-v2/src/state.rs, relay-server-v2/src/main.rs</files>
  <action>
Create src/state.rs with AppState struct using DashMap for concurrent access.

```rust
use dashmap::DashMap;
use std::sync::Arc;
use tokio::sync::mpsc;

use crate::session::generate_session_code;

/// A connected mac-client session
pub struct Session {
    pub code: String,
    pub client_id: String,
    /// Channel to send messages to the mac-client
    pub mac_tx: mpsc::Sender<Vec<u8>>,
}

/// Shared application state
#[derive(Clone)]
pub struct AppState {
    inner: Arc<AppStateInner>,
}

struct AppStateInner {
    /// Session code -> Session data
    sessions: DashMap<String, Session>,
}

impl AppState {
    pub fn new() -> Self {
        Self {
            inner: Arc::new(AppStateInner {
                sessions: DashMap::new(),
            }),
        }
    }

    /// Register a new mac-client, returns unique session code
    pub fn register_mac_client(&self, client_id: String, mac_tx: mpsc::Sender<Vec<u8>>) -> String {
        // Generate code with collision check
        let code = loop {
            let candidate = generate_session_code();
            if !self.inner.sessions.contains_key(&candidate) {
                break candidate;
            }
            tracing::debug!("Session code collision, regenerating");
        };

        self.inner.sessions.insert(
            code.clone(),
            Session {
                code: code.clone(),
                client_id,
                mac_tx,
            },
        );

        tracing::info!(code = %code, "Mac-client registered");
        code
    }

    /// Validate a session code, returns true if valid
    pub fn validate_session_code(&self, code: &str) -> bool {
        self.inner.sessions.contains_key(code)
    }

    /// Get the mac-client sender for a session code
    pub fn get_mac_sender(&self, code: &str) -> Option<mpsc::Sender<Vec<u8>>> {
        self.inner.sessions.get(code).map(|s| s.mac_tx.clone())
    }

    /// Remove a session (when mac-client disconnects)
    pub fn remove_session(&self, code: &str) {
        if self.inner.sessions.remove(code).is_some() {
            tracing::info!(code = %code, "Session removed");
        }
    }

    /// Get count of active sessions (for debugging)
    pub fn session_count(&self) -> usize {
        self.inner.sessions.len()
    }
}

impl Default for AppState {
    fn default() -> Self {
        Self::new()
    }
}
```

Update main.rs:
1. Add `mod state;` and `mod session;` declarations
2. Create AppState and pass to router with `.with_state(state)`
3. Add a debug route `/debug/sessions` that returns session count

```rust
// In main.rs, add route:
.route("/debug/sessions", get(debug_sessions))

// Handler:
async fn debug_sessions(State(state): State<AppState>) -> String {
    format!("Active sessions: {}", state.session_count())
}
```
  </action>
  <verify>
```bash
cd relay-server-v2 && cargo build 2>&1 | tail -5
cd relay-server-v2 && cargo run &
sleep 2
curl http://localhost:3000/debug/sessions
pkill -f "relay-server"
```
Expected output: "Active sessions: 0"
  </verify>
  <done>AppState compiles, server responds with session count, collision-checking works</done>
</task>

</tasks>

<verification>
1. `cargo test` passes all session tests
2. `cargo build` succeeds
3. `/debug/sessions` endpoint returns count
</verification>

<success_criteria>
- Session codes use clean 31-char alphabet (no 0/O/1/I/L)
- Collision checking prevents duplicate codes
- AppState uses DashMap for concurrent access
- Mac-client registration stores session with sender channel
- Session validation works for browser authentication
</success_criteria>

<output>
After completion, create `.planning/phases/04-relay-server/04-02-SUMMARY.md`
</output>
