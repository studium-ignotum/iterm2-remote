---
phase: 04-relay-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - relay-server-v2/Cargo.toml
  - relay-server-v2/src/main.rs
  - relay-server-v2/src/protocol.rs
autonomous: true

must_haves:
  truths:
    - "cargo build compiles without errors"
    - "cargo run starts server on configured port"
    - "Protocol types can serialize/deserialize JSON messages"
  artifacts:
    - path: "relay-server-v2/Cargo.toml"
      provides: "Project configuration with all dependencies"
      contains: "axum"
    - path: "relay-server-v2/src/main.rs"
      provides: "Entry point with basic axum router"
      contains: "Router::new"
    - path: "relay-server-v2/src/protocol.rs"
      provides: "Control message types"
      contains: "ControlMessage"
  key_links:
    - from: "relay-server-v2/src/main.rs"
      to: "tokio::main"
      via: "async runtime"
      pattern: "#\\[tokio::main\\]"
---

<objective>
Initialize the Rust relay server project with all dependencies and define the protocol message types.

Purpose: Establish the foundation for the v2.0 relay server - project structure, dependencies, and shared types that all other components will use.
Output: Compilable Rust project with axum router skeleton and protocol types.
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-relay-server/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Rust project with dependencies</name>
  <files>relay-server-v2/Cargo.toml, relay-server-v2/src/main.rs</files>
  <action>
Create new Rust project in `relay-server-v2/` directory (separate from existing Node.js relay-server).

1. Create Cargo.toml with these exact dependencies (versions from research):
```toml
[package]
name = "relay-server"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.8", features = ["ws"] }
tokio = { version = "1", features = ["full"] }
tower-http = { version = "0.6", features = ["cors", "trace"] }
rust-embed = { version = "8.11", features = ["compression"] }
axum-embed = "0.2"
nanoid = "0.4"
dashmap = "6"
tokio-util = { version = "0.7", features = ["time"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tracing = "0.1"
tracing-subscriber = "0.3"
futures-util = "0.3"
```

2. Create src/main.rs with basic axum server:
- Use tracing_subscriber for logging
- Create Router with placeholder route at "/" returning "Relay Server v2"
- Bind to 0.0.0.0:3000 (configurable via PORT env var)
- Log startup message with port

Use `std::env::var("PORT").unwrap_or_else(|_| "3000".to_string())` for port.
  </action>
  <verify>
```bash
cd relay-server-v2 && cargo build 2>&1 | tail -5
cd relay-server-v2 && cargo run &
sleep 2
curl http://localhost:3000/
pkill -f "relay-server"
```
  </verify>
  <done>Project compiles and server responds to HTTP request on port 3000</done>
</task>

<task type="auto">
  <name>Task 2: Create protocol message types</name>
  <files>relay-server-v2/src/protocol.rs, relay-server-v2/src/main.rs</files>
  <action>
Create src/protocol.rs with the control message types needed for relay communication.

Define these types using serde for JSON serialization:

```rust
use serde::{Deserialize, Serialize};

/// Control messages sent as JSON over WebSocket Text frames.
/// Terminal I/O is sent as Binary frames (not wrapped in ControlMessage).
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ControlMessage {
    // Mac-client -> Relay
    Register { client_id: String },

    // Relay -> Mac-client
    Registered { code: String },
    BrowserConnected { browser_id: String },
    BrowserDisconnected { browser_id: String },

    // Browser -> Relay
    Auth { session_code: String },

    // Relay -> Browser
    AuthSuccess,
    AuthFailed { reason: String },

    // Bidirectional
    Error { message: String },
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SessionInfo {
    pub id: String,
    pub name: String,
    pub connected_at: String,
}
```

Key design decisions:
- Use `#[serde(tag = "type")]` for tagged enum serialization ({"type": "register", "client_id": "..."})
- Use snake_case for JSON field names
- Keep it minimal - expand as needed in later phases

Update main.rs to include `mod protocol;` declaration.
  </action>
  <verify>
```bash
cd relay-server-v2 && cargo build 2>&1 | tail -3
cd relay-server-v2 && cargo test 2>&1 | tail -5
```
Add a quick test in protocol.rs:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_serialize_register() {
        let msg = ControlMessage::Register { client_id: "test".into() };
        let json = serde_json::to_string(&msg).unwrap();
        assert!(json.contains("\"type\":\"register\""));
    }
}
```
  </verify>
  <done>Protocol types compile and serialize to expected JSON format</done>
</task>

</tasks>

<verification>
1. `cd relay-server-v2 && cargo build` succeeds
2. `cd relay-server-v2 && cargo test` passes
3. Server starts and responds to requests
</verification>

<success_criteria>
- Rust project exists at relay-server-v2/
- All dependencies in Cargo.toml match research specifications
- Server binds to PORT env var (default 3000)
- ControlMessage enum serializes with tagged format
- Project is ready for state and WebSocket implementation
</success_criteria>

<output>
After completion, create `.planning/phases/04-relay-server/04-01-SUMMARY.md`
</output>
